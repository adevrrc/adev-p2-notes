{"0": {
    "doc": "About Box Form",
    "title": "About Box Form",
    "content": ". | Control | | . ",
    "url": "http://localhost:8888/adev2008/windows-forms-apps/about-box-form/",
    "relUrl": "/adev2008/windows-forms-apps/about-box-form/"
  },"1": {
    "doc": "Accessing Base Class Fields",
    "title": "Accessing Base Class Fields",
    "content": "Derived classes inherit the attributes of its base class. If you coded the base class, part of your testing will include verifying that an object’s entire state is set. Consider the follow class hierarchy: . public abstract class Shape { private string color; } public class Circle : Shape { private double radius; } . Part of testing the Circle class would be verifying the color state is correct. [TestMethod] public void Constructor_Color_Initialized() { // Arrange string color = \"Black\"; double radius = 77.7; // Act Circle circle = new Circle(color, radius); PrivateObject target; target = new PrivateObject(circle, new PrivateType(typeof(Shape))); string actual = (string)target.GetField(\"color\"); // Assert Assert.AreEqual(color, actual); } . Notes: . | Uses an overloaded version of the PrivateObject constructor. The second argument is a PrivateType instance to the base class Shape. | . ",
    "url": "http://localhost:8888/adev2008/unit-testing/accessing-base-class-fields/",
    "relUrl": "/adev2008/unit-testing/accessing-base-class-fields/"
  },"2": {
    "doc": "ADO.NET Basics",
    "title": "ADO.NET Basics",
    "content": ". | What is ADO.Net | Common classes . | Purpose of each class | Common class members | . | . ",
    "url": "http://localhost:8888/adev2008/adonet/ado-net-basics/",
    "relUrl": "/adev2008/adonet/ado-net-basics/"
  },"3": {
    "doc": "ADO.NET",
    "title": "ADO.Net",
    "content": "The section will help you answer the following questions: . | How can I use a database to store, retrieve and update data in my application? | Is there a library of functionality that can make working with data in a database easier? | How can an application run more efficiently using multi-threading? | . ",
    "url": "http://localhost:8888/adev2008/adonet/adonet/#adonet",
    "relUrl": "/adev2008/adonet/adonet/#adonet"
  },"4": {
    "doc": "ADO.NET",
    "title": "Learning Objectives",
    "content": ". | Write a .NET application that retrieves and updates data in a database. | Explain the role of data sets and providers. | Understand the work flow of an application that uses ADO.NET. | Develop an application that combines ADO.NET and Data Binding. | Understand the role of threads in an application. | . ",
    "url": "http://localhost:8888/adev2008/adonet/adonet/#learning-objectives",
    "relUrl": "/adev2008/adonet/adonet/#learning-objectives"
  },"5": {
    "doc": "ADO.NET",
    "title": "ADO.NET",
    "content": " ",
    "url": "http://localhost:8888/adev2008/adonet/adonet/",
    "relUrl": "/adev2008/adonet/adonet/"
  },"6": {
    "doc": "Advanced Techniques",
    "title": "Advanced Techniques",
    "content": ". | Not sure if this topic is necessary; if the approach is always to data bind to a collection | these topics could be blended with other pages | . ",
    "url": "http://localhost:8888/adev2008/data-binding/advanced-techniques/",
    "relUrl": "/adev2008/data-binding/advanced-techniques/"
  },"7": {
    "doc": "Appendixes",
    "title": "Appendixes",
    "content": " ",
    "url": "http://localhost:8888/adev2008/appendixes/appendixes/",
    "relUrl": "/adev2008/appendixes/appendixes/"
  },"8": {
    "doc": "Assembly References",
    "title": "Assembly References",
    "content": " ",
    "url": "http://localhost:8888/adev2008/csharp-oop/assembly-references/",
    "relUrl": "/adev2008/csharp-oop/assembly-references/"
  },"9": {
    "doc": "Assembly References",
    "title": "Table of Contents",
    "content": ". | Add a Reference To a Project | . To use types defined within class library assemblies, your project must contain a reference to the assembly. This is a two step process: . | Copy the .dll assembly file to the bin/Debug directory of your project. | Add a reference to the .dll assembly file in Visual Studio. | . ",
    "url": "http://localhost:8888/adev2008/csharp-oop/assembly-references/#table-of-contents",
    "relUrl": "/adev2008/csharp-oop/assembly-references/#table-of-contents"
  },"10": {
    "doc": "Assembly References",
    "title": "Add a Reference To a Project",
    "content": ". | To add a reference to a project, right-click on the References node in Solution Explorer and choose Add Reference… in the context menu. | The Reference Manager dialog window will appear. Click the Browse.. button. | Navigate to the bin/Debug directory within your project and select the .dll assembly file. | Click the OK button to add the reference. | . You will now be able to see the reference as a node underneath References. Once the assembly has been added to the project, you can now access the types within it. ",
    "url": "http://localhost:8888/adev2008/csharp-oop/assembly-references/#add-a-reference-to-a-project",
    "relUrl": "/adev2008/csharp-oop/assembly-references/#add-a-reference-to-a-project"
  },"11": {
    "doc": "Class Libraries",
    "title": "Class Libraries",
    "content": " ",
    "url": "http://localhost:8888/adev2008/csharp-oop/class-libraries/",
    "relUrl": "/adev2008/csharp-oop/class-libraries/"
  },"12": {
    "doc": "Class Libraries",
    "title": "Table of Contents",
    "content": ". | Creating a New Project | Solution File Structure | Visual Studio Solution Explorer | Building the Project | Further Reading | . A Class Library is a project that contains types and methods used by applications. The compiled result of a class library is a Dynamic Link Library (DLL). ",
    "url": "http://localhost:8888/adev2008/csharp-oop/class-libraries/#table-of-contents",
    "relUrl": "/adev2008/csharp-oop/class-libraries/#table-of-contents"
  },"13": {
    "doc": "Class Libraries",
    "title": "Creating a New Project",
    "content": "Creating a Class Library project follows the same steps as a Console Application, except that you will choose a different project template. When you get to the Create a new project window, the project type you want to choose is called “Class Library (.NET Framework)”. You can use the search to filter the list. ",
    "url": "http://localhost:8888/adev2008/csharp-oop/class-libraries/#creating-a-new-project",
    "relUrl": "/adev2008/csharp-oop/class-libraries/#creating-a-new-project"
  },"14": {
    "doc": "Class Libraries",
    "title": "Solution File Structure",
    "content": "If you navigate to the location you created the project to, you’ll find the solution directory for the project you created. At this point you may have more than one Visual Studio solution stored in this location. Read the directories careful to determine the one you are looking for. Solution Directory . The solution directory contains: . | Project Directory - You will see one directory for each project in the solution. New solutions will only contain one project and thus will have one project directory. | Solution File (.sln) - A file that ends with the file extension .sln. The .sln file contains information the Visual Studio environment needs to find and load the solution’s associated projects and resources. | . Project Directory . The project directory contains: . | bin Directory - Where the resulting files of a successful project build are stored. | obj Directory - This directory can be ignored. We won’t be using it in this course. | Properties Directory - This is another directory that can be ignored. | MS Build File (.csproj) File - The MSBuild file for the Visual Studio project. | Class1.cs - This file contains a class called Class1 and is created by default because of the project template that was chosen when creating the project. | . Class1 is not an appropriate name for a class. You should rename this file and the class identifier within it. ",
    "url": "http://localhost:8888/adev2008/csharp-oop/class-libraries/#solution-file-structure",
    "relUrl": "/adev2008/csharp-oop/class-libraries/#solution-file-structure"
  },"15": {
    "doc": "Class Libraries",
    "title": "Visual Studio Solution Explorer",
    "content": ". When the newly created class library project is loaded into Visual Studio, the Solution Explorer will contain the following: . | Properties - This node can be ignored. | References - This node contains the project references to other class libraries. | Class1.cs - The source code file Class1.cs that contains the Class1 class. | . In a future topic, you will learn how to add references to other class libraries to your VS projects. ",
    "url": "http://localhost:8888/adev2008/csharp-oop/class-libraries/#visual-studio-solution-explorer",
    "relUrl": "/adev2008/csharp-oop/class-libraries/#visual-studio-solution-explorer"
  },"16": {
    "doc": "Class Libraries",
    "title": "Building the Project",
    "content": "Building (Compile) a Project was discussed in a previous topic. On a successful build of a Console Application Project, the following files will be generated in the bin\\Debug directory within the Project directory. The files you see in the screenshot above are: . | Dynamic Link Library File (.dll) - The assembly file, which is the compiled version of your project. | Program Database File (.pdb) - The program database file that contains debugging information about the library. You can ignore this file. | . ",
    "url": "http://localhost:8888/adev2008/csharp-oop/class-libraries/#building-the-project",
    "relUrl": "/adev2008/csharp-oop/class-libraries/#building-the-project"
  },"17": {
    "doc": "Class Libraries",
    "title": "Further Reading",
    "content": ". | The .NET Framework Assembly | . ",
    "url": "http://localhost:8888/adev2008/csharp-oop/class-libraries/#further-reading",
    "relUrl": "/adev2008/csharp-oop/class-libraries/#further-reading"
  },"18": {
    "doc": "Classes",
    "title": "Classes",
    "content": " ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/classes/",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/classes/"
  },"19": {
    "doc": "Classes",
    "title": "Table of Contents",
    "content": ". | Declaring a Class | Defining a Class | Overloading Constructors | Overriding Methods | Documentation | Further Reading | . In the previous level of programming, you learned that you can define your own data types. These data types are complex, meaning they typically store more than one piece of data and contain functionality for using the data. A Class is the basic programming construct used for accomplishing this task. This document is not a detailed lesson on classes. It is expected at this point in your training that you are familiar with classes, class members, and how they are implemented. This document highlights some of the differences between C# and Java. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/classes/#table-of-contents",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/classes/#table-of-contents"
  },"20": {
    "doc": "Classes",
    "title": "Declaring a Class",
    "content": "Declaring a class in C# is the same as Java, with the exception of wrapping it within a namespace block. namespace ADEV.Education { public class Student { } } . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/classes/#declaring-a-class",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/classes/#declaring-a-class"
  },"21": {
    "doc": "Classes",
    "title": "Defining a Class",
    "content": "Your class will include the fields and methods required for defining that type. Fields should be declared at the top of the class block, followed by constructor methods and the remaining methods below. namespace ADEV.Education { public class Student { // Fields private string name; private int identificationNumber; // Methods } } . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/classes/#defining-a-class",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/classes/#defining-a-class"
  },"22": {
    "doc": "Classes",
    "title": "Overloading Constructors",
    "content": "In Java, you learned that you can overload methods. Due to the implementation of the methods being so similar, it is very common to invoke another version of the method so that you are not duplicating code. When invoking constructors, you use the this qualifier. In Java, the Student class constructors may look like this: . public Student() { this(\"\"); } public Student(string name) { this(name, 99999); } public Student(string name, int identificationNumber) { this.name = name; this.identificationNumber = identificationNumber; } . In C#, those same methods would be implemented as: . public Student() : this(\"\") { // Invoke Student(string) } public Student(string name) : this(name, 99999) { // Invokes Student(string, int) } public Student(string name, int identificationNumber) { this.name = name; this.identificationNumber = identificationNumber; } . The call to another constructor method is done after the declaration of the constructor. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/classes/#overloading-constructors",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/classes/#overloading-constructors"
  },"23": {
    "doc": "Classes",
    "title": "Overriding Methods",
    "content": "In the previous programming level, you learned that when classes derive from other classes, you can override the implementation of a base class method in the derived class. To be able to override a method in any OOP language, the base class method must be declared as virtual and the derived class must include a method with the same identifier and signature. In Java, all methods are declared as virtual. To override a base class method, you simply declare a method in the derived class with the same identifier and signature. In C#, not all methods are virtual. Also, you must specify when a method is overriding versus just creating another method with the same name and signature. You will see in a later topic how to declare a method as virtual. The following example will override the ToString() implementation inherited from the System.Object class. public override string ToString() { return string.Format(\"{0} {1}\", this.identificationNumber, this.name); } . Notice how the override keyword is needed to override the method. It is very common for Java programmers to leave out the override keyword, as it is not needed in the Java language. Omitting the override keyword will not give you a syntax error in C#, as its acceptable to code a method with the same identifier and signature in a derived class. The result of which effects how polymorphism will work for the method. If the intension of the method is to override the behavior of the base class, you must use the keyword override. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/classes/#overriding-methods",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/classes/#overriding-methods"
  },"24": {
    "doc": "Classes",
    "title": "Documentation",
    "content": "Documentation is required for each class and all of the class’ members (except for private fields). Check out a sample of how a class is documented. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/classes/#documentation",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/classes/#documentation"
  },"25": {
    "doc": "Classes",
    "title": "Further Reading",
    "content": ". | Introduction to Classes | . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/classes/#further-reading",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/classes/#further-reading"
  },"26": {
    "doc": "Coding Conventions and Standards",
    "title": "Coding Conventions and Standards",
    "content": " ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/coding-conventions-standards/",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/coding-conventions-standards/"
  },"27": {
    "doc": "Coding Conventions and Standards",
    "title": "Table of Contents",
    "content": ". | Layout | Identifier Guidelines | Documentation | Code Commenting | Identifier Conventions | Block Style | Indenting Code | Whitespace | Form Design | Further Reading | . All programmers are required to follow standards. A standard is an accepted way of doing something. Although programming standards do not need to be followed in order for your source code to produce its expected results, there are many reasons why you should follow programming standards. Standards ensure that the development of source code in a specific language is done in the same way by everyone. This makes working with other’s code much easier, since it is written in a way that is already familiar to you. The problem with standards is they are not consistent. Standards can vary between organizations, organizational departments, and supervisors in an organization, schools, programs and instructors. In this course, instructors have developed a general set of standards that all students will be expected to follow. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/coding-conventions-standards/#table-of-contents",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/coding-conventions-standards/#table-of-contents"
  },"28": {
    "doc": "Coding Conventions and Standards",
    "title": "Layout",
    "content": ". | Use default code editor settings (smart indenting, four-character indent, tabs saved as spaces). | Write one statement per line. | Write one declaration per line. | Add one blank line between method and property definitions. | . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/coding-conventions-standards/#layout",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/coding-conventions-standards/#layout"
  },"29": {
    "doc": "Coding Conventions and Standards",
    "title": "Identifier Guidelines",
    "content": ". | Namespace: | Classes and Other User-defined types: | Fields and Variables: | Methods and Other Class Members: | Parameters: | . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/coding-conventions-standards/#identifier-guidelines",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/coding-conventions-standards/#identifier-guidelines"
  },"30": {
    "doc": "Coding Conventions and Standards",
    "title": "Documentation",
    "content": "All documentation must be XML style documentation. Class . /// &lt;summary&gt; /// Represents a Person. /// &lt;/summary&gt; . Documentation blocks are always written on the line before the item they are documenting. Do not include a line space between the documentation and what is being documented. /// &lt;summary&gt; /// Represents a Person. /// &lt;/summary&gt; public class Person . Methods . All methods (excluding main) of a class must be preceded by XML style documentation. The documentation must contain the following in this exact format: . | Method Description/Purpose. | List of parameters and descriptions of their use in the method (if the method has parameters defined). | Description of what value the method returns, and it’s purpose (if the method returns a value). | . /// &lt;summary&gt; /// Subtracts the specified amount from the Person's amount of money. /// &lt;/summary&gt; /// &lt;param name=\"amount\"&gt;The amount of money to be subtracted.&lt;/param&gt; public void SubtractMoney(decimal amount) { } /// &lt;summary&gt; /// Returns the String representation of a Person. /// &lt;/summary&gt; /// &lt;returns&gt;The String representation of a Person.&lt;/returns&gt; public override string ToString() { } . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/coding-conventions-standards/#documentation",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/coding-conventions-standards/#documentation"
  },"31": {
    "doc": "Coding Conventions and Standards",
    "title": "Code Commenting",
    "content": "Comments are a way of annotating your source code in plain English that assists others in determining what a statement or set of statements is doing. Documentation vs. Comments Although documentation is written using comment syntax, the purpose of documentation and comments are very different. Comments are written for someone reading the source code. Documentation is written and published for other developers using the code. Single Line Comment . Use single line comments (//) to explain a single statement if it is complex. These comments always precede the line of code they are describing. // Calculates the amount of tax charged to the customer. tax = purchaseAmount * TaxRate; . | Leave one blank line after the “//”. | Capitalize the first character of the comment. | Must be free of spelling mistakes. | . Comments are less formal than documentation, meaning that some grammar rules are not always followed. Block Comment . Use a block comment (/*…*/) when the comment is too long to fit on a single line. These comments always precede the line(s) of code they are describing. /* Calculates the amount of tax charged to the customer. The tax rate based on store location. */ tax = purchaseAmount * TaxRate; . Many programmers use single line comment syntax when commenting over multiple lines. The following is acceptable practice: . // Calculates the amount of tax charged to the customer. // The tax rate based on store location. tax = purchaseAmount * TaxRate; . No matter what type of comment you choose, they should always be preceded by a blank line (in most cases), as this makes reading the comments much easier. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/coding-conventions-standards/#code-commenting",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/coding-conventions-standards/#code-commenting"
  },"32": {
    "doc": "Coding Conventions and Standards",
    "title": "Identifier Conventions",
    "content": "All identifiers (names) must be descriptive. Reading the name should give the reader an idea of what data is for. The following are naming conventions specific to each identifier type: . Class Identifiers . Must have the first letter of each word capitalized. The naming convention is called pascal-case. public class HelloWorld { } . Variable Identifiers . The first word in the identifier is always lowercase, all subsequent words have the first letter in uppercase. This convention is called camel-case. int countOfItemsInCustomerTable; . Method Identifiers . All method, properties and event class member identifiers start with a uppercase letter, all subsequent words have the first letter in uppercase. public static int GetCustomerCount(); . Constants . The first letter of the identifier is uppercase, all subsequent words have the first letter in uppercase. const double TaxRate = 4.5; . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/coding-conventions-standards/#identifier-conventions",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/coding-conventions-standards/#identifier-conventions"
  },"33": {
    "doc": "Coding Conventions and Standards",
    "title": "Block Style",
    "content": "In C#, blocks of code are represented by the braces ‘{‘ and ‘}’. The standard in this course is to always start the block below the construct the block is for. public static void Main(string[] args) { } . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/coding-conventions-standards/#block-style",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/coding-conventions-standards/#block-style"
  },"34": {
    "doc": "Coding Conventions and Standards",
    "title": "Indenting Code",
    "content": "Not all statements start in the first character position of a line. Code is indented, or moved to the right, so related items can be kept together. Indenting code helps improve readability, as it is easy to see what code belongs to what block. The rules for indenting are: . Classes . Class declarations are always made in the first character position (not indented at all). The opening curly brace of a class block is coded in the first character position on the next line. All code in the class block is indented one tab (typically 4 spaces or 1 tab). The closing curly brace of a class is always on a line by itself in the first character position. Methods . Method declarations are always indented inside the class they belong to. The opening curly brace is on the next line, directly under the first character of the line above. The code inside the method block is indented. The closing curly brace of a class is always on a line by itself and must align with the opening curly brace of the method block. All Other Blocks . Opening brace is on the next line, directly under the first character of the line above. All code in that block is indented to the right. The closing curly brace of a class is always on a line by itself and must align with the opening curly brace of the block. public class HelloWorld { public static void Main(string[] args) { int radius = 4; if (radius == 4) { // statements within the block would go here } } } . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/coding-conventions-standards/#indenting-code",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/coding-conventions-standards/#indenting-code"
  },"35": {
    "doc": "Coding Conventions and Standards",
    "title": "Whitespace",
    "content": "Operators . One space is included before and after an operator, except when the operator is a unary operator. // Correct sum = sum + 5; // Incorrect sum=sum+5; // Correct sum++; // Incorrect sum ++; // Correct multiplier = (sum &gt; 10) ? 3 : 8; // Incorrect multiplier=(sum&gt;10)?3:8; . Line Spacing . The use of whitespace (blank lines) also helps improve readability. The standards for whitespace are as follows: . | If the class has using statements, there are no blank lines between each using statement. | A blank line (line 2 in the example below) must be placed before the documentation for the class if there are import statements. | There are no blank lines between a class or method and its documentation. | Leave a blank line (line 15 in the example below) before the documentation of a method, expect if it’s the first method in the class. | . using System; /// &lt;summary&gt; /// Class documentation. /// &lt;/summary&gt; public class ClassName { /// &lt;summary&gt; /// Method documentation. /// &lt;/summary&gt; public void FirstMethod() { } /// &lt;summary&gt; /// Method documentation. /// &lt;/summary&gt; public void SecondMethod() { } } . There is no blank line after the opening curly brace of any block. If there are multiple closing curly braces in consecutive lines (lines 8 - 10), there are no blank lines between the closing braces. if(expression) { for(expression) { if(expression) { } } } . When commenting, make sure there is a blank line (line 5) before the comment. The blank line is not included when the comment is the first line of a block. public static void Main(string[] args) { // Comment for statement statement /* comment for statement */ statement } . When commenting, do not place any blank lines between the comment and the line of code it’s describing. // comment for statement statement /* comment for statement */ statement . Include a blank line (line 4) after local variable declaration statements. public static void Main(string[] args) { int localVariable; // method statements here } . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/coding-conventions-standards/#whitespace",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/coding-conventions-standards/#whitespace"
  },"36": {
    "doc": "Coding Conventions and Standards",
    "title": "Form Design",
    "content": "For Windows Forms App projects where you are given a design for the forms, the expectation is that you will create form designs that will match the requirements you are given. The requirements will be in the form of both a image and/or text descriptions. The expectation of your form designs will not require you to generate an exact pixel-to-pixel copy, but rather, a form that has no noticeable differences between what you develop and what the requirement is. To give you a better idea of the expectations, consider the design requirement below, and the designs completed by past students. Original Design Requirement . Student Completed Designs . Here is a sample of a student that followed the requirements very well. Here is a sample of a student that did not follow the requirements very well. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/coding-conventions-standards/#form-design",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/coding-conventions-standards/#form-design"
  },"37": {
    "doc": "Coding Conventions and Standards",
    "title": "Further Reading",
    "content": ". | Capitalization Conventions | General Naming Conventions | Names of Assemblies and DLLs | Names of Namespaces | Names of Classes, Structs and Interfaces | Names of Type Members | Naming Parameters | . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/coding-conventions-standards/#further-reading",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/coding-conventions-standards/#further-reading"
  },"38": {
    "doc": "ComboBox Data Binding",
    "title": "ComboBox Data Binding",
    "content": ". | What is simple data binding | . ",
    "url": "http://localhost:8888/adev2008/data-binding/combobox-data-binding/",
    "relUrl": "/adev2008/data-binding/combobox-data-binding/"
  },"39": {
    "doc": "Complex Data Binding",
    "title": "Complex Data Binding",
    "content": ". | What is simple data binding | . ",
    "url": "http://localhost:8888/adev2008/data-binding/complex-data-binding/",
    "relUrl": "/adev2008/data-binding/complex-data-binding/"
  },"40": {
    "doc": "Console Application Project",
    "title": "Console Application Project",
    "content": " ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/console-application-project/",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/console-application-project/"
  },"41": {
    "doc": "Console Application Project",
    "title": "Table of Contents",
    "content": ". | Creating a New Project | Solution File Structure | Visual Studio Solution Explorer | Building a Console Application Project | . Console Applications are applications that execute within the console. When you developed Java applications in the previous level of programming, they too were executed in the console. In .NET, source code and other applications resources are managed within a Visual Studio Project. This is a much more structured approach to how you manually managed source code files in Java. Visual Studio Projects are managed within a Visual Studio Solution. Solutions can contain one or more Projects. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/console-application-project/#table-of-contents",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/console-application-project/#table-of-contents"
  },"42": {
    "doc": "Console Application Project",
    "title": "Creating a New Project",
    "content": "The easiest way to create a new Visual Studio Project, and thus a Visual Studio Solution, is to just simply launch Visual Studio. When you launch Visual Studio a splash screen will normally appear. When the splash screen closes, the launch window appears. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/console-application-project/#creating-a-new-project",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/console-application-project/#creating-a-new-project"
  },"43": {
    "doc": "Console Application Project",
    "title": "Launch Window",
    "content": ". Click the Create a new project button to start configuring a new project. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/console-application-project/#launch-window",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/console-application-project/#launch-window"
  },"44": {
    "doc": "Console Application Project",
    "title": "Choose Project Template Window",
    "content": "The next part of the project creation process is to choose a project type. There are many templates to create starting points for certain types of projects. These templates will include assembly references, build configurations, source code files and resources. The project type you want to use for creating a console application in this course is called “Console App (.NET Framework)”. Ensure that you are choosing the project template that is specifically for C#. In the image above, you can see that the selected project on the right has “C#” listed as one of the tags for the project template. When choosing a project template, read carefully. There is typically more than one project template called “Console App (.NET Framework)”. For example, there is a project called “Console App (.NET Framework)” but is configured to work with the Visual Basic programming language, as noted by the “Visual Basic” tag. Also, there are many project templates labeled as “Console App”. You want to choose the project template that ends with “(.NET Framework)”. Depending on how you installed Visual Studio, the number of project templates listed can be quite large. Use the search input to filter the list. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/console-application-project/#choose-project-template-window",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/console-application-project/#choose-project-template-window"
  },"45": {
    "doc": "Console Application Project",
    "title": "Configure New Project Window",
    "content": "Next, you’ll need to configure the project. Modify the following: . | Project Name - Names the project directory and will be the default namespace for all project files. | Location - Sets the directory where the solution/project will be saved. | Solution Name - Names the solution directory. Changing the Project Name will automatically update the Solution Name, but can be changed to meet your needs. | Uncheck “Place solution and project in the same directory”. | . | Framework - Always use “.NET Framework 4.7.2”. | . Click the Create button to create the project. This will create all the directories and files required for the project type you selected and launch the Visual Studio Solution. Double check your inputs before clicking “Create”. Some of these choices cannot be changed after creating the projects. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/console-application-project/#configure-new-project-window",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/console-application-project/#configure-new-project-window"
  },"46": {
    "doc": "Console Application Project",
    "title": "Solution File Structure",
    "content": "If you navigate to the location you created the project to, you’ll find the solution directory for the project you created. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/console-application-project/#solution-file-structure",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/console-application-project/#solution-file-structure"
  },"47": {
    "doc": "Console Application Project",
    "title": "Solution Directory",
    "content": ". The solution directory contains: . | Project Directory - You will see one directory for each project in the solution. New solutions will only contain one project and thus will have one project directory. | Solution File (.sln) - A file that ends with the file extension .sln. The .sln file contains information the Visual Studio environment needs to find and load the solution’s associated projects and resources. | . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/console-application-project/#solution-directory",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/console-application-project/#solution-directory"
  },"48": {
    "doc": "Console Application Project",
    "title": "Project Directory",
    "content": ". The project directory contains: . | bin Directory - Where the resulting files of a successful project build are stored. | obj Directory - This directory can be ignored. We won’t be using it in this course. | Properties Directory - This is another directory that can be ignored. | MS Build File (.csproj) File - The MSBuild file for the Visual Studio project. | App.config - An XML file that can be used to store settings for you application. | Program.cs - A file that ends with .cs is a C# Source Code file. This file contains a class called Program and is created by default because of the project template that was chosen when creating the project. | . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/console-application-project/#project-directory",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/console-application-project/#project-directory"
  },"49": {
    "doc": "Console Application Project",
    "title": "Visual Studio Solution Explorer",
    "content": ". When the newly created class library project is loaded into Visual Studio, the Solution Explorer will contain the following: . | Properties - This node can be ignored. | References - This node contains the project references to other class libraries. | Class1.cs - The source code file Class1.cs that contains the Class1 class. | . In a future topic, you will learn how to add references to other class libraries to your VS projects. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/console-application-project/#visual-studio-solution-explorer",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/console-application-project/#visual-studio-solution-explorer"
  },"50": {
    "doc": "Console Application Project",
    "title": "Building a Console Application Project",
    "content": "Building (Compile) a Project was discussed in a previous topic. On a successful build of a Console Application Project, the following files will be generated in the bin\\Debug directory within the Project directory. The files you see in the screenshot above are: . | Executable Assembly File (.exe) - The assembly file, which is the compiled version of your project. | Application Configuration File (.config) - This is a copy of the App.config file. | Program Database File (.pdb) - The program database file that contains debugging information about the program. You can ignore this file. | . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/console-application-project/#building-a-console-application-project",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/console-application-project/#building-a-console-application-project"
  },"51": {
    "doc": "Console I/O",
    "title": "Console Input/Output",
    "content": " ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/console-io/#console-inputoutput",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/console-io/#console-inputoutput"
  },"52": {
    "doc": "Console I/O",
    "title": "Table of Contents",
    "content": ". | Input / Output Streams | Output Text To the Console . | Formatting Output | . | Reading From the Console | Further Reading | . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/console-io/#table-of-contents",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/console-io/#table-of-contents"
  },"53": {
    "doc": "Console I/O",
    "title": "Input / Output Streams",
    "content": "In C# a stream is an abstract representation of a device on which input and output operations can be performed. The devices which we can stream to and from are things like the operating system’s standard output (console), standard input (keyboard), and the file system. You can think of a stream as a source or a destinations for a potentially unlimited sequence of bytes. The System.Console class is a class that represents the standard input, output and error streams for console applications. The Console class is used for all input and output to the console. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/console-io/#input--output-streams",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/console-io/#input--output-streams"
  },"54": {
    "doc": "Console I/O",
    "title": "Output Text To the Console",
    "content": "In Java, to output text to the console you needed to reference the standard output stream by using System.out. In C#, you can accomplish the same by using the Console class. Console.Out . The Out class member returns a reference to a TextWriter object. The TextWriter class has two method for outputting text to a stream: . | Write() | WriteLine() | . Write() is equivalent to Java’s java.io.PrintStream.print() method and WriteLine() is equivalent to Java’s java.io.PrintStream.println(). Console.Out.Write(\"This will output without a line break. \"); Console.Out.WriteLine(\"This will output with a line break.\"); . Output: . This will output without a line break. This will output with a line break. These output operations can be simplified by using the Write() and WriteLine() methods of the Console class. string name = \"Chris\"; Console.Write(\"Hello, \"); Console.WriteLine(name + \"!\"); Console.WriteLine(\"Today is going to be a great day!\"); . Output: . Hello, Chris! Today is going to be a great day! . Formatting Output . Write() and WriteLine() are overloaded methods, with versions that work like Java’s java.io.PrintStream.printf() method. string name = \"Chris\"; DateTime date = DateTime.Now; Console.WriteLine(\"Hello, {0}! Today is {1}, it's {2:HH:mm} now.\", name, date.DayOfWeek, date); . Output: . Hello, Chris! Today is Tuesday, it's 11:14 now. The “{}” signifies a placeholder and the integer value within it curly-braces signifies an index used to reference the arguments after the string argument. Formatting strings like this is called Composite Formatting. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/console-io/#output-text-to-the-console",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/console-io/#output-text-to-the-console"
  },"55": {
    "doc": "Console I/O",
    "title": "Reading From the Console",
    "content": "The Console class can also be used for reading input from the console using the Read() and ReadLine() methods. Read() will read the next character from the stream and ReadLine() reads an entire line of data from the stream. Console.Write(\"(Y/N)? \"); char choice = (char)Console.Read(); Console.WriteLine(choice); // flush output buffer Console.WriteLine(); Console.Write(\"Enter your full name: \"); string fullname = Console.ReadLine(); Console.WriteLine(fullname); . Output: . (Y/N)? y y Enter your full name: Kenny Omega Kenny Omega . The Console.In class member returns a TextReader object. Using Console.In is not required when you use Console.Read() and Console.ReadLine(). ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/console-io/#reading-from-the-console",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/console-io/#reading-from-the-console"
  },"56": {
    "doc": "Console I/O",
    "title": "Further Reading",
    "content": ". | Console Class Documentation | Composite Formatting | . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/console-io/#further-reading",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/console-io/#further-reading"
  },"57": {
    "doc": "Console I/O",
    "title": "Console I/O",
    "content": " ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/console-io/",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/console-io/"
  },"58": {
    "doc": "Constructor Tests",
    "title": "Constructor Tests",
    "content": " ",
    "url": "http://localhost:8888/adev2008/unit-testing/constructor-tests/",
    "relUrl": "/adev2008/unit-testing/constructor-tests/"
  },"59": {
    "doc": "Constructor Tests",
    "title": "Table of Contents",
    "content": ". | Example 1 - Exception | Non-Test Methods | Example 2 - Initialize State | . ",
    "url": "http://localhost:8888/adev2008/unit-testing/constructor-tests/#table-of-contents",
    "relUrl": "/adev2008/unit-testing/constructor-tests/#table-of-contents"
  },"60": {
    "doc": "Constructor Tests",
    "title": "Example 1 - Exception",
    "content": "Test Case: . | # | Test Case | Test Data | Expected | . | 1 | Exception when name is null | Parameter name: null, Parameter amountOfMoney: 500 | ArgumentNullException, Parameter: name, Message: The argument must reference a string object. | . Testing Goal: The goal of this test is to cause the expected exception to be thrown and the exception should have the expected state. [TestMethod] public void Constructor_NameNull_Exception() { // Arrange string name = null; decimal amountOfMoney = 500; // Act &amp; Assert ArgumentNullException exception = Assert.ThrowsException&lt;ArgumentNullException&gt;(() =&gt; new Person(name, amountOfMoney)); // Assert exception state Assert.AreEqual(\"name\", exception.ParamName); Assert.AreEqual(\"The argument must reference a string object.\", GetExceptionMessage(exception.Message)); } . Notes: . | The act part of the test is new Person(name, amountOfMoney). | The Assert.ThrowsException&amp;lt;T&amp;gt;() method generates a AssertFailedException if the type of exception is not thrown. If the type of exception is thrown, a reference to the exception object is returned. | The assert part of the test includes verifying the parameter and message of the exception. | . ",
    "url": "http://localhost:8888/adev2008/unit-testing/constructor-tests/#example-1---exception",
    "relUrl": "/adev2008/unit-testing/constructor-tests/#example-1---exception"
  },"61": {
    "doc": "Constructor Tests",
    "title": "Non-Test Methods",
    "content": "Unit test class can also contain methods that aren’t unit test methods. These methods do not have the TestMethod attribute. The test above calls a method called GetExceptionMessage which extracts only the message from the Exception’s Message property. /// &lt;summary&gt; /// Utility method to obtain only the message from an Exception object. /// &lt;/summary&gt; /// &lt;param name=\"exceptionMessage\"&gt;The Exception's Message state.&lt;/param&gt; /// &lt;returns&gt;The Exception's message with the parameter omitted.&lt;/returns&gt; /// &lt;remarks&gt; /// The Exception.Message property returns the Exception's message on line 1 and /// the parameter name on line 2. This method reads the first line and returns /// the message. /// &lt;/remarks&gt; private string GetExceptionMessage(string exceptionMessage) { return new System.IO.StringReader(exceptionMessage).ReadLine(); } . Feel free to include this method in your test class. ",
    "url": "http://localhost:8888/adev2008/unit-testing/constructor-tests/#non-test-methods",
    "relUrl": "/adev2008/unit-testing/constructor-tests/#non-test-methods"
  },"62": {
    "doc": "Constructor Tests",
    "title": "Example 2 - Initialize State",
    "content": "Test Case: . | # | Test Case | Test Data | Expected | . | 6 | Initialize the amount of money to positive value | Parameter name: “Kenny”, Parameter amountOfMoney: 500 | 500 | . Testing Goal: The goal of this test is initialize the state of the object and verify it did so correctly. [TestMethod] public void Constructor_AmountOfMoney_Initialize() { // Arrange string name = \"Kenny\"; decimal amountOfMoney = 500; // Act Person person = new Person(name, amountOfMoney); // Reflection PrivateObject target = new PrivateObject(person); // Obtain object state decimal actual = (decimal)target.GetField(\"amountOfMoney\"); // Assert Assert.AreEqual(amountOfMoney, actual); } . Notes: . | Because the state is stored in a private field, the PrivateObject class is used to gain access to the class private class member. | The GetField() method returns an object type. Because fields can be any type, the method uses this polymorphic reference to the value of the field. A type cast is necessary to store the value in the decimal variable. | . ",
    "url": "http://localhost:8888/adev2008/unit-testing/constructor-tests/#example-2---initialize-state",
    "relUrl": "/adev2008/unit-testing/constructor-tests/#example-2---initialize-state"
  },"63": {
    "doc": "C# Fundamentals",
    "title": "C# Fundamentals",
    "content": "C# (pronounced “see sharp”) is a modern Object-Oriented Programming language. It is one of the most popular of the programming languages supported by the .NET. C# is a C-based language. It’s syntax is influenced by other languages like C, C++, and Java. If you are comfortable developing in either of the aforementioned languages, you can already read C# code. Here is an example of the traditional “Hello World” program written in C#: . using System; namespace ADEV.BIT.ADEV.RRC.Module1 { internal class Program { static void Main(string[] args) { Console.WriteLine(\"Hello World\"); Console.Write(\"Press any key to continue...\"); Console.ReadKey(); } } } . As you can see from the sample code above, C# has a very similar syntax to Java. Many of the keywords are the same. Some of the words are different, but based on context, you should have a good understanding what they represent. More often than not, the syntax you used to develop Java code will work in C#. The following will highlight the similarities and differences from Java. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/csharp-fundamentals/",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/csharp-fundamentals/"
  },"64": {
    "doc": "C# Fundamentals",
    "title": "Further Reading",
    "content": ". | Tour of C# | . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/csharp-fundamentals/#further-reading",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/csharp-fundamentals/#further-reading"
  },"65": {
    "doc": "C# OOP",
    "title": "C# Object-Oriented Programming",
    "content": "The section will help you answer the following questions: . | How do I code various modules of code in C#? | What are the common practices and implementation of Object-Oriented Programming in C#? | How am I able to use code in assemblies? | . ",
    "url": "http://localhost:8888/adev2008/csharp-oop#c-object-oriented-programming",
    "relUrl": "/adev2008/csharp-oop#c-object-oriented-programming"
  },"66": {
    "doc": "C# OOP",
    "title": "Learning Objectives",
    "content": ". | Develop classes and structs that are defined with C# Properties. | Develop class hierarchies using abstract classes and inheritance. | Define and implement interfaces. | Develop a Static Class. | Develop code to generate and handle exceptions. | Add references to a project to use code in other assemblies. | . ",
    "url": "http://localhost:8888/adev2008/csharp-oop#learning-objectives",
    "relUrl": "/adev2008/csharp-oop#learning-objectives"
  },"67": {
    "doc": "C# OOP",
    "title": "C# OOP",
    "content": " ",
    "url": "http://localhost:8888/adev2008/csharp-oop",
    "relUrl": "/adev2008/csharp-oop"
  },"68": {
    "doc": "Data Binding Basics",
    "title": "Data Binding Basics",
    "content": ". | What is data binding | Why data binding | . ",
    "url": "http://localhost:8888/adev2008/data-binding/data-binding-basics/",
    "relUrl": "/adev2008/data-binding/data-binding-basics/"
  },"69": {
    "doc": "Data Binding",
    "title": "Data Binding",
    "content": "The section will help you answer the following questions: . | How can I store data to retrieve at a later time? | Much of the code I write in a Windows forms application is changing the state of the UI. How can I reduce the amount of UI code I write? | What is Data Binding? | . ",
    "url": "http://localhost:8888/adev2008/data-binding/data-binding/",
    "relUrl": "/adev2008/data-binding/data-binding/"
  },"70": {
    "doc": "Data Binding",
    "title": "Learning Objectives",
    "content": ". | Read and write data to and from a file. | Explain the role of data binding in a Windows Forms Application. | Develop a Form class that uses data binding. | . ",
    "url": "http://localhost:8888/adev2008/data-binding/data-binding/#learning-objectives",
    "relUrl": "/adev2008/data-binding/data-binding/#learning-objectives"
  },"71": {
    "doc": "Data Structures",
    "title": "Data Structures",
    "content": "The section will help you answer the following questions: . | What is a data structure? | What are the commonly used data structures? | How do data structures differ from one another? | . ",
    "url": "http://localhost:8888/adev2008/data-structures/data-structures/",
    "relUrl": "/adev2008/data-structures/data-structures/"
  },"72": {
    "doc": "Data Structures",
    "title": "Learning Objectives",
    "content": ". | Learn array basics. | Understand the difference between standard and generic collections. | Explore collection types: List, Dictionary, SortedList, Stack, Queue. | . Data Structures are a means of organizing and storing data such that we can perform operations on the data efficiently. There are many types of data structures, each of which are used for a specific task. ",
    "url": "http://localhost:8888/adev2008/data-structures/data-structures/#learning-objectives",
    "relUrl": "/adev2008/data-structures/data-structures/#learning-objectives"
  },"73": {
    "doc": "Data Structures",
    "title": "Arrays",
    "content": "An array is a data structure of fixed size that store items of a single type. Arrays are indexed. This allows elements to be randomly accessed. double[] grades; grades = new double[35]; Student[] students = new Student[45]; grades[0] = 97; students[14] = new Student(); double[] temperatures = new double[] { 14.5, 18.6, 23.1, 34.7 }; string[] letterGrades = { \"F\", \"D\", \"C\", \"C+\", \"B\", \"B+\", \"A\", \"A+\" }; foreach(double temperature in temperatures) { Console.WriteLine(temperature); } . Inserting and deleting elements is not possible because arrays are a fixed size. You can however create a new array, using the elements of an array, with more or less elements. The System.Array class defines methods for working with arrays. ",
    "url": "http://localhost:8888/adev2008/data-structures/data-structures/#arrays",
    "relUrl": "/adev2008/data-structures/data-structures/#arrays"
  },"74": {
    "doc": "Data Structures",
    "title": "Collections",
    "content": "Collections are data structures used to manage groups of related object. Although arrays can store references to objects, collections provide a more flexible way to work with groups of objects. Collections can grow and shrink dynamically. Standard vs. Generic . If the collection contains elements of a single type, you can use one of the Generic collection types. These types are found within the System.Collections.Generic namespace. Generic collections are type safe, only allowing the declared type to be added to it. When you retrieve an element, you won’t have to determine the type or convert it. Microsoft recommends you avoid using standard collections. They recommend using the generic equivalent. ",
    "url": "http://localhost:8888/adev2008/data-structures/data-structures/#collections",
    "relUrl": "/adev2008/data-structures/data-structures/#collections"
  },"75": {
    "doc": "Data Structures",
    "title": "List&lt;T&gt;",
    "content": "Represents a strongly typed list of objects that can be accessed by index. Provides methods to search, sort, and manipulate lists. List&lt;string&gt; names = new List&lt;string&gt;(); List&lt;int&gt; numbers = new List&lt;int&gt; { 1, 2, 3 }; names.Add(\"Kenny\"); names.Add(\"Matt\"); names.Add(\"Nick\"); Console.WriteLine(names[0]); // Kenny foreach(string name in names) { Console.WriteLine(name); } // Kenny // Matt // Nick names.Remove(\"Matt\"); Console.WriteLine(names.Count); // 2 names.Clear(); . ",
    "url": "http://localhost:8888/adev2008/data-structures/data-structures/#listt",
    "relUrl": "/adev2008/data-structures/data-structures/#listt"
  },"76": {
    "doc": "Data Structures",
    "title": "Dictionary&lt;TKey, TValue&gt;",
    "content": "Represents a collection of key/value pairs that are organized based on the key. Dictionary&lt;string, int&gt; spells = new Dictionary&lt;string, int&gt;(); spells.Add(\"Smite\", 1); spells.Add(\"Shadow Word: Pain\", 2); spells.Add(\"Mind Blast\", 5); Console.WriteLine(spells.Count); // 3 Console.WriteLine(spells.ContainsKey(\"Smite\")); // true Console.WriteLine(\"Spell level: {0}\", spells[\"Mind Blast\"]); // Spell level: 5 foreach (string key in spells.Keys) { Console.WriteLine(\"{0} is level {1}.\", key, spells[key]); } // Smite is level 1. // Shadow Word: Pain is level 2. // Mind Blast is level 5. spells.Remove(\"Smite\"); spells.Clear(); . ",
    "url": "http://localhost:8888/adev2008/data-structures/data-structures/#dictionarytkey-tvalue",
    "relUrl": "/adev2008/data-structures/data-structures/#dictionarytkey-tvalue"
  },"77": {
    "doc": "Data Structures",
    "title": "SortedList&lt;TKey, TValue&gt;",
    "content": "Represents a collection of key/value pairs that are sorted by key based on the associated IComparer&lt;T&gt; implementation. The SortedList will sort elements by key. Keys are sorted based on how objects of that type are sorted. Each time an element is added the SortedList will reorder its elements. SortedList&lt;string, decimal&gt; menuItems = new SortedList&lt;string, decimal&gt;(); menuItems.Add(\"Pizza\", 15); menuItems.Add(\"Hot Dog\", 2); menuItems.Add(\"Noodles\", 5); Console.WriteLine(menuItems.Count); // 3 Console.WriteLine(menuItems.ContainsKey(\"Noodles\")); // true Console.WriteLine(\"Hot dog price: {0:C}\", menuItems[\"Hot Dog\"]); // Hot dog price: $2.00 for(int i = 0; i &lt; menuItems.Count; i++) { Console.WriteLine(\"{0} is {1:C}\", menuItems.Keys[i], menuItems.Values[i]); } // Hot Dog is $2.00 // Noodles is $5.00 // Pizza is $15.00 menuItems.Remove(\"Pizza\"); menuItems.Clear(); . An ArgumentException is thrown when you attempt to add a duplicate key. ",
    "url": "http://localhost:8888/adev2008/data-structures/data-structures/#sortedlisttkey-tvalue",
    "relUrl": "/adev2008/data-structures/data-structures/#sortedlisttkey-tvalue"
  },"78": {
    "doc": "Data Structures",
    "title": "Stack&lt;T&gt;",
    "content": "Represents a last in, first out (LIFO) collection of objects. Stacks have two key operations: . | Push - Inserts an element onto the top of the stack. | Pop - Removes the topmost element and returns it. | . Stack&lt;string&gt; friends = new Stack&lt;string&gt;(); friends.Push(\"Kenny\"); friends.Push(\"Matt\"); friends.Push(\"Nick\"); string friend = friends.Pop(); Console.WriteLine(friend); // Nick Console.WriteLine(friends.Count); // 2 Console.WriteLine(friends.Peek()); // Matt friends.Clear(); . ",
    "url": "http://localhost:8888/adev2008/data-structures/data-structures/#stackt",
    "relUrl": "/adev2008/data-structures/data-structures/#stackt"
  },"79": {
    "doc": "Data Structures",
    "title": "Queue&lt;T&gt;",
    "content": "Represents a first in, first out (FIFO) collection of objects. Queues have two key operations: . | Enqueue - Inserts an element onto the end of the queue. | Dequeue - Removes the element at the beginning of the queue and returns it. | . Queue&lt;string&gt; enemies = new Queue&lt;string&gt;(); enemies.Enqueue(\"Kenny\"); enemies.Enqueue(\"Matt\"); enemies.Enqueue(\"Nick\"); string enemy = enemies.Dequeue(); Console.WriteLine(enemy); // Kenny Console.WriteLine(enemies.Count); // 2 Console.WriteLine(enemies.Peek()); // Matt enemies.Clear(); . ",
    "url": "http://localhost:8888/adev2008/data-structures/data-structures/#queuet",
    "relUrl": "/adev2008/data-structures/data-structures/#queuet"
  },"80": {
    "doc": "Data Structures",
    "title": "Further Reading",
    "content": ". | Collections | List | Dictionary | SortedList | Stack | Queue | . ",
    "url": "http://localhost:8888/adev2008/data-structures/data-structures/#further-reading",
    "relUrl": "/adev2008/data-structures/data-structures/#further-reading"
  },"81": {
    "doc": "Data Types",
    "title": "Data Types",
    "content": " ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/data-types/",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/data-types/"
  },"82": {
    "doc": "Data Types",
    "title": "Table of Contents",
    "content": ". | Value Types . | Boolean Type | Decimal Type | . | Reference Types . | Object Type | String Type | . | Further Reading | . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/data-types/#table-of-contents",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/data-types/#table-of-contents"
  },"83": {
    "doc": "Data Types",
    "title": "Value Types",
    "content": "All the data types you are familiar with exist in C#: . | byte, char, double, float, int, long, short | . Boolean Type . The boolean type exists in C#, but uses a different keyword than Java: . bool isDone; . Decimal Type . C# also includes a floating-point type used for currency values. It is more accurate than using the double type. decimal paymentAmount = 34.23M; . Like Java, a floating-point literal (Ex. 34.23) is considered a double type. A float literal is expressed by succeeding the literal value with an ‘F’ (Ex. 34.23F) and a decimal literal with an ‘M’ (Ex. 34.23M). ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/data-types/#value-types",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/data-types/#value-types"
  },"84": {
    "doc": "Data Types",
    "title": "Reference Types",
    "content": "Object Type . Like Java, the object type is the base type for all reference types (just written without the capital ‘O’). How the object type differs, is how it is the base type for all reference types and value types. object widget; . String Type . In Java, the String type is referenced using the String class name. In C#, the String type is written as string, which is the alias to the System.String .NET type in the Common Type System (CTS). string firstName = \"Chris\";` . For the most part, you will not see any difference between the Java String and the C# string. It is best practice to be familiar with the members of the string type for any programming language you are developing with. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/data-types/#reference-types",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/data-types/#reference-types"
  },"85": {
    "doc": "Data Types",
    "title": "Further Reading",
    "content": ". | Integral Numeric Types | Floating-point Numeric Types | Built-in Numeric Conversions | Boolean Type | Character Type | String Interpolation | String Verbatim Token | . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/data-types/#further-reading",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/data-types/#further-reading"
  },"86": {
    "doc": "Debugging",
    "title": "Debugging",
    "content": ". | Using the Debugger Tool | Debug Class | . ",
    "url": "http://localhost:8888/adev2008/windows-forms-apps/debugging/",
    "relUrl": "/adev2008/windows-forms-apps/debugging/"
  },"87": {
    "doc": "Delegates",
    "title": "Delegates",
    "content": " ",
    "url": "http://localhost:8888/adev2008/events/delegates/",
    "relUrl": "/adev2008/events/delegates/"
  },"88": {
    "doc": "Delegates",
    "title": "Table of Contents",
    "content": ". | Declaring Delegates | Creating Delegate Instances | Using Delegates | Multicast Delegate | Documentation | . Delegates are special types of .NET classes whose instances store references to methods. Delegates allow you to pass methods as arguments to other methods. The delegate object can be passed to code which can call the referenced method, without the code knowing at compile time which method it will call. ",
    "url": "http://localhost:8888/adev2008/events/delegates/#table-of-contents",
    "relUrl": "/adev2008/events/delegates/#table-of-contents"
  },"89": {
    "doc": "Delegates",
    "title": "Declaring Delegates",
    "content": "The declaration of a delegate looks more like a method than a class, but has no body. namespace ADEV.Events { /// &lt;summary&gt; /// Represents the method that will handle an instructor action. /// &lt;/summary&gt; public delegate void InstructorAction(); } . Every delegate has a signature. A signature includes the identifier, number of parameters and parameter types. Unlike methods, the return type of the delegate is part of the signature. When you declare a delegate type, you are specifying the types of methods the delegate can represent. A delegate instance can only reference a method that matches the delegate signature. Delegates would be coded in their own code file. The example above would be coded in a file called InstructorAction.cs. internal class Program { static void Main(string[] args) { } static void AlertStudent() { } static void DisplayStudentGrades(int[] grades) { } } . In the Program class above, the AlertStudent() method signature matches that of the delegate InstructorAction(). Therefore, a instance of the delegate could reference the AlertStudent() method. The DisplayStudentGrades(int[]) method does not have a matching signature and would not be able to be referenced by a delegate of the InstructorAction() type. ",
    "url": "http://localhost:8888/adev2008/events/delegates/#declaring-delegates",
    "relUrl": "/adev2008/events/delegates/#declaring-delegates"
  },"90": {
    "doc": "Delegates",
    "title": "Creating Delegate Instances",
    "content": "Creating a delegate instance is similar to creating other objects. The delegate constructor always takes one argument, which is the identifier of the method you want the delegate to reference. internal class Program { static void Main(string[] args) { InstructorAction alertStudentAction; alertStudentAction = new InstructorAction(AlertStudent); } static void AlertStudent() { Console.WriteLine(\"ALERT! Your test average is below the standard.\"); } } . The syntax can be simplified to: . class Program { static void Main(string[] args) { InstructorAction alertStudentAction = AlertStudent; } static void AlertStudent() { Console.WriteLine(\"ALERT! Your test average is below the standard.\"); } } . ",
    "url": "http://localhost:8888/adev2008/events/delegates/#creating-delegate-instances",
    "relUrl": "/adev2008/events/delegates/#creating-delegate-instances"
  },"91": {
    "doc": "Delegates",
    "title": "Using Delegates",
    "content": "To use the delegate, you simply use the variable as if it was the method that it references. class Program { static void Main(string[] args) { InstructorAction alertStudentAction = AlertStudent; // Invoke the method alertStudentAction(); } static void AlertStudent() { Console.WriteLine(\"ALERT! Your test average is below the standard.\"); } } . Output: . ALERT! Your test average is below the standard. The example above demonstrates how you would invoke the method a delegate references. But seems rather pointless, considering the method is in the same class. The benefit of delegates is in passing the method to another piece of code. public class Student { public void AddTestMark(double mark, InstructorAction action) { if (mark &lt; 0 || mark &gt; 1) throw new ArgumentOutOfRangeException(\"mark\", \"The mark must be a value of zero or greater.\"); this.NumberOfTests++; this.SumOfTests += mark; double testAverage = this.SumOfTests / this.NumberOfTests; if (action != null &amp;&amp; this.NumberOfTests &gt; 3 &amp;&amp; testAverage &lt; .65) { action(); // or // action.Invoke(); } } } . class Program { static void Main(string[] args) { InstructorAction alertStudentAction = AlertStudent; Student student = new Student(); student.AddTestMark(.11, alertStudentAction); student.AddTestMark(.52, alertStudentAction); student.AddTestMark(.33, alertStudentAction); student.AddTestMark(.64, alertStudentAction); } static void AlertStudent() { Console.WriteLine(\"ALERT! Your test average is below the standard.\"); } } . Output: . ALERT! Your test average is below the standard. ",
    "url": "http://localhost:8888/adev2008/events/delegates/#using-delegates",
    "relUrl": "/adev2008/events/delegates/#using-delegates"
  },"92": {
    "doc": "Delegates",
    "title": "Multicast Delegate",
    "content": "If delegates weren’t cool enough, they can actually reference more than one method. This is called a multicast delegate. When the delegate is used, all the methods it references are called one after another. class Program { static void Main(string[] args) { InstructorAction alertStudentAction += AlertStudent; // Adds a second method to the delegate alertStudentAction += AlertGuardian; Student student = new Student(); student.AddTestMark(.11, alertStudentAction); student.AddTestMark(.52, alertStudentAction); student.AddTestMark(.33, alertStudentAction); student.AddTestMark(.64, alertStudentAction); } static void AlertStudent() { Console.WriteLine(\"ALERT! Your test average is below the standard.\"); } static void AlertGuardian() { Console.WriteLine(\"ALERT! Your dependant's test average is below the standard.\"); } } . Output: . ALERT! Your test average is below the standard. ALERT! Your dependant's test average is below the standard. The += operator adds a method to the delegates invocation list. The -= operator removes a method from the delegates invocation list. ",
    "url": "http://localhost:8888/adev2008/events/delegates/#multicast-delegate",
    "relUrl": "/adev2008/events/delegates/#multicast-delegate"
  },"93": {
    "doc": "Delegates",
    "title": "Documentation",
    "content": ". | Delegate | . ",
    "url": "http://localhost:8888/adev2008/events/delegates/#documentation",
    "relUrl": "/adev2008/events/delegates/#documentation"
  },"94": {
    "doc": "Documentation Samples",
    "title": "Documentation Samples",
    "content": " ",
    "url": "http://localhost:8888/adev2008/appendixes/documentation-samples/",
    "relUrl": "/adev2008/appendixes/documentation-samples/"
  },"95": {
    "doc": "Documentation Samples",
    "title": "Table of Contents",
    "content": ". | Class | Enumeration | Exceptions | Interfaces | Delegate | Events | Event Handler Methods | . In the previous level of programming, you learned the importance of documenting classes and class members. In this course, the documentation will look different, but the purpose and process is the same. Use the following examples as reference for the work you will do in this course. The implementation of the methods and properties have been omitted on purpose. ",
    "url": "http://localhost:8888/adev2008/appendixes/documentation-samples/#table-of-contents",
    "relUrl": "/adev2008/appendixes/documentation-samples/#table-of-contents"
  },"96": {
    "doc": "Documentation Samples",
    "title": "Class",
    "content": "Things to take note of: . | The class is documented. | Fields are not documented. | Documentation is completed using XML style documentation (not Javadoc style). | All XML elements contain information about the class or class member. | . using System; namespace ADEV.Documentation.Samples { /// &lt;summary&gt; /// Represents a Person. /// &lt;/summary&gt; public class Person { private string name; private decimal amountOfMoney; /// &lt;summary&gt; /// Gets the Person's name. /// &lt;/summary&gt; public string Name { } /// &lt;summary&gt; /// Gets and sets the amount of money the Person has. /// &lt;/summary&gt; public decimal AmountOfMoney { } /// &lt;summary&gt; /// Initializes an instance of the Person class with the specified name and amount of money. /// &lt;/summary&gt; /// &lt;param name=\"name\"&gt;The Person's name.&lt;/param&gt; /// &lt;param name=\"amount\"&gt;The amount of money the Person has.&lt;/param&gt; public Person(string name, decimal amount) { } /// &lt;summary&gt; /// Initializes an instance of the Person class with the specified name and no money. /// &lt;/summary&gt; /// &lt;param name=\"name\"&gt;The Person's name.&lt;/param&gt; public Person(string name) : this(name, 0) { } /// &lt;summary&gt; /// Adds the specified amount to the Person's amount of money. /// &lt;/summary&gt; /// &lt;param name=\"amount\"&gt;The amount of money to be added.&lt;/param&gt; public void AddMoney(decimal amount) { } /// &lt;summary&gt; /// Subtracts the specified amount from the Person's amount of money. /// &lt;/summary&gt; /// &lt;param name=\"amount\"&gt;The amount of money to be subtracted.&lt;/param&gt; public void SubtractMoney(decimal amount) { } /// &lt;summary&gt; /// Returns the String representation of a Person. /// &lt;/summary&gt; /// &lt;returns&gt;The String representation of a Person.&lt;/returns&gt; public override string ToString() { } } } . ",
    "url": "http://localhost:8888/adev2008/appendixes/documentation-samples/#class",
    "relUrl": "/adev2008/appendixes/documentation-samples/#class"
  },"97": {
    "doc": "Documentation Samples",
    "title": "Enumeration",
    "content": "Things to take note of: . | The enumeration is documented. | Each enumeration value is documented. | Documentation is completed using XML style documentation (not Javadoc style). | All XML elements contain information about the class or class member. | . using System; namespace ADEV.Documentation.Samples { /// &lt;summary&gt; /// Specifies the gears for a passenger vehicle. /// &lt;/summary&gt; public enum VehicleGear { /// &lt;summary&gt; /// The neutral gear. /// &lt;/summary&gt; Neutral, /// &lt;summary&gt; /// The first gear. /// &lt;/summary&gt; First, /// &lt;summary&gt; /// The second gear. /// &lt;/summary&gt; Second, /// &lt;summary&gt; /// The third gear. /// &lt;/summary&gt; Third, /// &lt;summary&gt; /// The fouth gear. /// &lt;/summary&gt; Fourth, /// &lt;summary&gt; /// The fifth gear. /// &lt;/summary&gt; Fifth, /// &lt;summary&gt; /// The sixth gear. /// &lt;/summary&gt; Sixth } } . ",
    "url": "http://localhost:8888/adev2008/appendixes/documentation-samples/#enumeration",
    "relUrl": "/adev2008/appendixes/documentation-samples/#enumeration"
  },"98": {
    "doc": "Documentation Samples",
    "title": "Exceptions",
    "content": "When a class member has the potential to generate an exception, details about that must be included in the class member’s documentation. Unlike most other elements of the XML documentation, the &lt;exception&gt; will not likely be auto-generated for you. You will need to manually code this into the documentation. Things to take note of: . | Documentation is completed using XML style documentation (not Javadoc style). | You must include one instance of the &lt;exception&gt;...&lt;/exception&gt; element per exception type generated by the class member. | . Sample 1 . In the sample code below, you can see an example of documentation that includes information about an exception that is generated in the unit. The exception in the sample is of type System.ArgumentOutOfRangeException. An example of the possible text within the &lt;exception&gt; element would be: “Thrown when the amount is less than zero.” . /// &lt;summary&gt; /// ... /// &lt;/summary&gt; /// &lt;param name=\"amount\"&gt;...&lt;/param&gt; /// &lt;exception cref=\"System.ArgumentOutOfRangeException\"&gt;Thrown when...&lt;/exception&gt; public void Bar(int amount) { // Implementation omitted from the sample } . Sample 2 . In this sample code, the exception type System.ArgumentOutOfRangeException is generated in more than one situation with different parameters. You can see that the documentation still only includes one exception element, but the description includes the various situations when that exception type is thrown. An example of the possible text within the &lt;exception&gt; element would be: “Thrown when the amount is less than zero or the tip is less than or equal to zero.” . /// &lt;summary&gt; /// ... /// &lt;/summary&gt; /// &lt;param name=\"amount\"&gt;...&lt;/param&gt; /// &lt;param name=\"tip\"&gt;...&lt;/param&gt; /// &lt;returns&gt;...&lt;/returns&gt; /// &lt;exception cref=\"System.ArgumentOutOfRangeException\"&gt;Thrown when amount is ... or when tip is ...&lt;/exception&gt; public int Bar(int amount, decimal tip) { // Implementation omitted from the sample } . Sample 3 . In this sample code, the unit generates two types of exceptions. Therefore, the documentation will include one exception element per type of exception that is generated. /// &lt;summary&gt; /// ... /// &lt;/summary&gt; /// &lt;param name=\"description\"&gt;...&lt;/param&gt; /// &lt;param name=\"amount\"&gt;...&lt;/param&gt; /// &lt;exception cref=\"System.FormatException\"&gt;Thrown when...&lt;/exception&gt; /// &lt;exception cref=\"System.ArgumentOutOfRangeException\"&gt;Thrown when...&lt;/exception&gt; public void Bar(String description, int amount) { // Implementation omitted from the sample } . The documentation of a method or property will contain one &lt;exception&gt; element for each type of exception thrown. Do not include an &lt;exception&gt; element for each throw of an exception of the same type.For example, if a method generates an ArgumentOutOfRangeException when one parameter is less than zero and an ArgumentOutOfRangeException when another parameter is less than zero, the method would only include one &lt;exception&gt; element with an explanation of the two possible ways the exception could happen. ",
    "url": "http://localhost:8888/adev2008/appendixes/documentation-samples/#exceptions",
    "relUrl": "/adev2008/appendixes/documentation-samples/#exceptions"
  },"99": {
    "doc": "Documentation Samples",
    "title": "Interfaces",
    "content": "Things to take note of: . | The interface is documented. | All interface members are documented. | Documentation is completed using XML style documentation (not Javadoc style). | All XML elements contain information about the class or class member. | . using System; namespace ADEV.Documentation.Samples { /// &lt;summary&gt; /// Provides a mechanism for hugging. /// &lt;/summary&gt; public interface IHuggable { /// &lt;summary&gt; /// Performs a hugging behavior. /// &lt;/summary&gt; void Hug(); } } . ",
    "url": "http://localhost:8888/adev2008/appendixes/documentation-samples/#interfaces",
    "relUrl": "/adev2008/appendixes/documentation-samples/#interfaces"
  },"100": {
    "doc": "Documentation Samples",
    "title": "Delegate",
    "content": "Things to take note of: . | The delegate is documented and explains what the method it references represent. | Documentation is completed using XML style documentation (not Javadoc style). | All XML elements contain information about the class or class member. | . namespace ADEV.Documentation.Samples { /// &lt;summary&gt; /// Represents the method that will handle an instructor action. /// &lt;/summary&gt; public delegate void InstructorAction(); } . ",
    "url": "http://localhost:8888/adev2008/appendixes/documentation-samples/#delegate",
    "relUrl": "/adev2008/appendixes/documentation-samples/#delegate"
  },"101": {
    "doc": "Documentation Samples",
    "title": "Events",
    "content": "Things to take note of: . | The event is documented and explains when the event takes place. | Documentation is completed using XML style documentation (not Javadoc style). | All XML elements contain information about the class or class member. | . using System; namespace ADEV.Documentation.Samples { public class Student { /// &lt;summary&gt; /// Occurs when the Student's test average falls below the standard. /// &lt;/summary&gt; public event EventHandler AverageBelowFail; /// &lt;summary&gt; /// Raises the AverageBelowFail event. /// &lt;/summary&gt; protected virtual void OnAverageBelowFail() { if (AverageBelowFail != null) { AverageBelowFail(this, EventArgs.Empty); } } } } . ",
    "url": "http://localhost:8888/adev2008/appendixes/documentation-samples/#events",
    "relUrl": "/adev2008/appendixes/documentation-samples/#events"
  },"102": {
    "doc": "Documentation Samples",
    "title": "Event Handler Methods",
    "content": "Things to take note of: . | The event handler method is documented and explains what event(s) it handles and which objects those events are for. | The auto-generated parameters are removed. | All XML elements contain information about the class or class member. | . // &lt;summary&gt; /// Handles the AverageBelowFail event of a Student. /// &lt;/summary&gt; static void Student_AverageBelowFail(object sender, EventArgs e) { } . ",
    "url": "http://localhost:8888/adev2008/appendixes/documentation-samples/#event-handler-methods",
    "relUrl": "/adev2008/appendixes/documentation-samples/#event-handler-methods"
  },"103": {
    "doc": "Enumerations",
    "title": "Enumerations",
    "content": "An Enumeration is a set of named constants. This user-defined type is very useful when a built-in type does not meet the value requirements for your needs. Enumerations are used frequently in the .NET Framework. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/enumerations/",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/enumerations/"
  },"104": {
    "doc": "Enumerations",
    "title": "Declaring",
    "content": "Declaring an enumeration is similar in syntax to a class, except you will use the enum keyword. public enum Suit . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/enumerations/#declaring",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/enumerations/#declaring"
  },"105": {
    "doc": "Enumerations",
    "title": "Defining",
    "content": "Defining an enumeration is simply a list of names that make up the enum members. namespace TableTopGame { public enum Suit { Hearts, Diamonds, Spades, Clubs } } . The enum member’s type is int by default. If no value is assigned to the enum member, the first enum member’s value would be zero, with each other member’s value incrementing by one. Enumerations can also be defined with specific values for the enum members. namespace Weather { public enum Direction { North = 34, South = 43, East = 12, West = 21 } } . In this course, each enumeration you define will be coded within its own file. Like you did in the previous level of programming, you will name the file using the identifier of what it contains. For example, for the Direction enumeration defined above, you would code this in a file called Direction.cs. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/enumerations/#defining",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/enumerations/#defining"
  },"106": {
    "doc": "Enumerations",
    "title": "Documentation",
    "content": "Documentation is required for each enumeration and all of the enumeration members. Check out a sample of how an enumeration is documented. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/enumerations/#documentation",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/enumerations/#documentation"
  },"107": {
    "doc": "Enumerations",
    "title": "Enumeration Values",
    "content": "You can use an enum member in your code, by specifying the enumeration the enum member is within, and using dot-notation to specify the enum member. Direction direction; // Syntax: Enumeration.EnumMember direction = Direction.North; Console.WriteLine(\"Wind is gusting {0}.\", direction); . Output: . Wind is gusting North. Because an enumeration underlying type is integral, you can type cast an enumeration value to use its associated integral value. int value = (int)direction; Console.WriteLine(value); . Output: . 34 . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/enumerations/#enumeration-values",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/enumerations/#enumeration-values"
  },"108": {
    "doc": "Enumerations",
    "title": "Enum Class",
    "content": "All enumerations derive from the base class Enum. The abstract class Enum provides a number of methods for working with enumerations. The following example demonstrates the IsDefined method of the Enum class, that returns true when the specified value is defined within the specified enumeration type; otherwise it returns false. direction = (Direction)999; Console.WriteLine(Enum.IsDefined(typeof(Direction), direction)); . Output: . False . The typeof() operator is used to retrieve a System.Type instance of the specified type. This gives you the ability to store the type of an object as an object. If you’d like to know more about the typeof() operator, check out Type Testing and Cast. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/enumerations/#enum-class",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/enumerations/#enum-class"
  },"109": {
    "doc": "Enumerations",
    "title": "Further Reading",
    "content": ". | Enumeration Type | Enum Class | . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/enumerations/#further-reading",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/enumerations/#further-reading"
  },"110": {
    "doc": "Event Handling",
    "title": "Event Handling",
    "content": " ",
    "url": "http://localhost:8888/adev2008/events/event-handling/",
    "relUrl": "/adev2008/events/event-handling/"
  },"111": {
    "doc": "Event Handling",
    "title": "Table of Contents",
    "content": ". | Defining An Event Handler Method | Subscribing To Events | object sender Parameter | EventArgs e Parameter | Custom EventArgs | Documentation | Further Reading | . To respond to an event, a Subscriber class must define an event handler method. This method is used to subscribe to an object’s event in a process called event wiring. When the event occurs, the delegate (event) will call the subscriber’s method. ",
    "url": "http://localhost:8888/adev2008/events/event-handling/#table-of-contents",
    "relUrl": "/adev2008/events/event-handling/#table-of-contents"
  },"112": {
    "doc": "Event Handling",
    "title": "Defining An Event Handler Method",
    "content": "An event handler method is no different than any other method except that the signature of the method must match that of the event it will be used to subscribe to. Most methods that you will subscribe to will use the EventHandler delegate defined as public delegate void EventHandler(object sender, EventArgs e);. class Program { static void Main(string[] args) { } static void Student_AverageBelowFail(object sender, EventArgs e) { Console.WriteLine(\"ALERT! Your test average is below the standard.\"); } } . It is common for event handler methods to be named using the format, Object_EventBeingHandled. ",
    "url": "http://localhost:8888/adev2008/events/event-handling/#defining-an-event-handler-method",
    "relUrl": "/adev2008/events/event-handling/#defining-an-event-handler-method"
  },"113": {
    "doc": "Event Handling",
    "title": "Subscribing To Events",
    "content": "Once the event handler method is declared and defined, the Subscriber class can subscribe to the object’s event. class Program { static void Main(string[] args) { Student student = new Student(); student.AverageBelowFail += Student_AverageBelowFail; } static void Student_AverageBelowFail(object sender, EventArgs e) { Console.WriteLine(\"ALERT! Your test average is below the standard.\"); } } . When the event is raised, the handler method will be invoked. class Program { static void Main(string[] args) { Student student = new Student(); student.AverageBelowFail += Student_AverageBelowFail; student.AddTestMark(.11); student.AddTestMark(.52); student.AddTestMark(.33); student.AddTestMark(.64); } static void Student_AverageBelowFail(object sender, EventArgs e) { Console.WriteLine(\"ALERT! Your test average is below the standard.\"); } } . ",
    "url": "http://localhost:8888/adev2008/events/event-handling/#subscribing-to-events",
    "relUrl": "/adev2008/events/event-handling/#subscribing-to-events"
  },"114": {
    "doc": "Event Handling",
    "title": "object sender Parameter",
    "content": "As mentioned previously, the sender parameter references the object that raised the event. This can be used in the event handler method to determine which object called the event handler method and/or to use the object within the event handler method implementation. static void Student_AverageBelowFail(object sender, EventArgs e) { Console.WriteLine(\"ALERT! {0}'s test average is below the standard.\", ((Student)sender).Name); } . The sender parameter is declared as object because it could be any type of object that uses this event handler method. This is an excellent example of using polymorphism. When you have a polymorphic reference, you are limited to accessing only members of the declared type. It is very typical for you to cast sender to a more specific type. ",
    "url": "http://localhost:8888/adev2008/events/event-handling/#object-sender-parameter",
    "relUrl": "/adev2008/events/event-handling/#object-sender-parameter"
  },"115": {
    "doc": "Event Handling",
    "title": "EventArgs e Parameter",
    "content": "The e parameter references an object of EventArgs type which can contain data about the event that took place. This allows object’s that raise events to pass data back to the event handler method. In most cases, this object will be empty, meaning it contains no data about the event. This is the default implementation of the EventArgs type. ",
    "url": "http://localhost:8888/adev2008/events/event-handling/#eventargs-e-parameter",
    "relUrl": "/adev2008/events/event-handling/#eventargs-e-parameter"
  },"116": {
    "doc": "Event Handling",
    "title": "Custom EventArgs",
    "content": "In the examples above, the event was raised using an blank EventArgs object. When there is no data to report about an event, an EventArgs instance is still required because the EventHandler delegate requires an argument for the EventArgs parameter. When your event requires data to send back to the handling method, you will need to define your own EventArgs type. public class AverageBelowFailEventArgs : EventArgs { public double BelowAverageDifference { get; } public AverageBelowFailEventArgs(double belowAverageDifference) { this.BelowAverageDifference = belowAverageDifference; } } . The Student class would be updated to: . public class Student { public event EventHandler&lt;AverageBelowFailEventArgs&gt; AverageBelowFail; public void AddTestMark(double mark) { if(mark &lt; 0) throw new ArgumentOutOfRangeException(\"mark\", \"The mark must be a value of zero or greater.\"); this.NumberOfTests++; this.SumOfTests += mark; double testAverage = this.SumOfTests / this.NumberOfTests; if(this.NumberOfTest &gt; 3 &amp;&amp; testAverage &lt; .65) { OnAverageBelowFail(new AverageBelowFailEventArgs(.65 - average)); } } protected virtual void OnAverageBelowFail(AverageBelowFailEventArgs eventArgs) { if(AverageBelowFail != null) { AverageBelowFail(this, eventArgs); } } } . The event handler method would include the custom EventArgs as the second parameter type. static void Student_AverageBelowFail(object sender, AverageBelowFailEventArgs e) { Console.WriteLine(\"ALERT! Your test average is {0:P} below the standard.\", e.BelowAverageDifference); } . ",
    "url": "http://localhost:8888/adev2008/events/event-handling/#custom-eventargs",
    "relUrl": "/adev2008/events/event-handling/#custom-eventargs"
  },"117": {
    "doc": "Event Handling",
    "title": "Documentation",
    "content": ". | Event Handler Methods | . ",
    "url": "http://localhost:8888/adev2008/events/event-handling/#documentation",
    "relUrl": "/adev2008/events/event-handling/#documentation"
  },"118": {
    "doc": "Event Handling",
    "title": "Further Reading",
    "content": ". | Handle and Raise Events | . ",
    "url": "http://localhost:8888/adev2008/events/event-handling/#further-reading",
    "relUrl": "/adev2008/events/event-handling/#further-reading"
  },"119": {
    "doc": "Event Class Members",
    "title": "Event Class Members",
    "content": " ",
    "url": "http://localhost:8888/adev2008/events/event-members/",
    "relUrl": "/adev2008/events/event-members/"
  },"120": {
    "doc": "Event Class Members",
    "title": "Table of Contents",
    "content": ". | Declaring an Event | The On Method | Raise the Event | Documentation | Further Reading | . Windows Forms Applications are graphical user interface applications built for the Windows desktop. Before you can learn about developing Windows Forms Applications, you must understand events and how to handle them. Events are a mechanism for object to notify other objects that something interesting happened to it. These events are typically used to notify that the object’s state has changed or an action was performed. Events are a special multicast delegates. An event can reference one or more methods. The class that contains the event is referred to as the publisher. Classes that need to respond to an object’s event will subscribe to the object’s event. These classes are referred to as subscribers. Microsoft has a standard pattern for setting up events in a publisher class. It requires three steps: . | Declare the event. | Declare and define an “On” method for the event. | Raise the event in the class. | . ",
    "url": "http://localhost:8888/adev2008/events/event-members/#table-of-contents",
    "relUrl": "/adev2008/events/event-members/#table-of-contents"
  },"121": {
    "doc": "Event Class Members",
    "title": "Declaring an Event",
    "content": "Events are members of a class. They are typically declared as public, as the intention of the event is to be accessible outside of the class. public class Student { public event EventHandler AverageBelowFail; } . The EventHandler type is a delegate. All events in the .NET class library are based on this delegate. It is declared as: . public delegate void EventHandler(object sender, EventArgs e); . The EventHandler delegate has two parameters. The parameters represent: . | A reference to the object that raised the event. | An empty EventArgs object. | . The object sender and EventArgs e parameters will be discussed in a later topic. Although events can be based on any delegate type, it is recommended that you base your events on the .NET pattern by using EventHandler. The event keyword is used when declaring the event. The event keyword prevents the delegate from being invoked outside of the class the event is declared in. ",
    "url": "http://localhost:8888/adev2008/events/event-members/#declaring-an-event",
    "relUrl": "/adev2008/events/event-members/#declaring-an-event"
  },"122": {
    "doc": "Event Class Members",
    "title": "The On Method",
    "content": "The second part of the pattern is to define a method to raise the event. The method identifier is prefixed with the word “On”, followed by the name of the event. protected virtual void OnAverageBelowFail() { if(AverageBelowFail != null) { AverageBelowFail(this, EventArgs.Empty); } } . In the sample code above, the delegate invokes the methods it references. Since the EventHandler delegate has two parameters, to invoke the delegate, you must provide two arguments: . You may be thinking at this point that this method is rather pointless, since the AverageBelowFail(this, EventArgs.Empty); statement can be coded at any point in the class. The advantage of using the “On” method is that when the class is a base class, the derived class will still be able to raise the event. Remember that events can only be invoked in the class they are declared in. The “On” method is inherited and can be called in the derived class. Also, the derived class could override this behavior if needed. ",
    "url": "http://localhost:8888/adev2008/events/event-members/#the-on-method",
    "relUrl": "/adev2008/events/event-members/#the-on-method"
  },"123": {
    "doc": "Event Class Members",
    "title": "Raise the Event",
    "content": "Raising the event simply means causing the delegate to invoke the methods it references. When following Microsoft’s recommended pattern, this means invoking the “On” method. Raising the event can happen in any method or property accessor. public class Student { public void AddTestMark(double mark) { if (mark &lt; 0 || mark &gt; 1) throw new ArgumentOutOfRangeException(\"mark\", \"The mark must be a value of zero or greater.\"); this.NumberOfTests++; this.SumOfTests += mark; double testAverage = this.SumOfTests / this.NumberOfTests; if (this.NumberOfTests &gt; 3 &amp;&amp; testAverage &lt; .65) { OnAverageBelowFail(); } } } . ",
    "url": "http://localhost:8888/adev2008/events/event-members/#raise-the-event",
    "relUrl": "/adev2008/events/event-members/#raise-the-event"
  },"124": {
    "doc": "Event Class Members",
    "title": "Documentation",
    "content": ". | Events | . ",
    "url": "http://localhost:8888/adev2008/events/event-members/#documentation",
    "relUrl": "/adev2008/events/event-members/#documentation"
  },"125": {
    "doc": "Event Class Members",
    "title": "Further Reading",
    "content": ". | Events | event Keyword | Publishing Events | Raising Events | . ",
    "url": "http://localhost:8888/adev2008/events/event-members/#further-reading",
    "relUrl": "/adev2008/events/event-members/#further-reading"
  },"126": {
    "doc": "Events",
    "title": "Events",
    "content": "The section will help you answer the following questions: . | How can I reserve a part of my code to be implemented by someone else at a later time? | Is it possible to store a method, like I can with other data types? | How can object’s interact more efficiently? | . ",
    "url": "http://localhost:8888/adev2008/events/events/",
    "relUrl": "/adev2008/events/events/"
  },"127": {
    "doc": "Events",
    "title": "Learning Objectives",
    "content": ". | Declare and use a Delegate. | Develop classes that are defined with events. | Develop an application that handles an object’s event. | . ",
    "url": "http://localhost:8888/adev2008/events/events/#learning-objectives",
    "relUrl": "/adev2008/events/events/#learning-objectives"
  },"128": {
    "doc": "Exceptions",
    "title": "Exceptions",
    "content": " ",
    "url": "http://localhost:8888/adev2008/csharp-oop/exceptions/",
    "relUrl": "/adev2008/csharp-oop/exceptions/"
  },"129": {
    "doc": "Exceptions",
    "title": "Table of Contents",
    "content": ". | Understanding Exceptions . | What is an Exception? | Flow of Code | Execution Call Stack | . | Unhandled Exceptions . | Unhandled Exceptions In Visual Studio | . | Handling Exceptions | Referencing Handled Exceptions | Anticipating Exceptions | Common .NET Exception Types | Generating Exceptions | Documentation | Testing Exceptions | Further Reading | . It is inevitable that at some point in the process of developing an application an error will occur. No matter how good of a programmer you are, errors will happen. Exceptions are special types of errors, generated by the operating system or by using someone else’s code. Newer programmers view exceptions as a negative part of programming, because when an exception is not handled your program will abnormally end. Exceptions are similar to compiler errors in that they aid a programmer into developing better code. To debug and fix exceptions, you must understand: . | what exceptions are. | how they affect the flow of code. | how to gain information from the exception. | how to handle an exception. | the requirements for how the exception should be handled. | . ",
    "url": "http://localhost:8888/adev2008/csharp-oop/exceptions/#table-of-contents",
    "relUrl": "/adev2008/csharp-oop/exceptions/#table-of-contents"
  },"130": {
    "doc": "Exceptions",
    "title": "Understanding Exceptions",
    "content": "Although exceptions are a tool for programmers to make their code better, they are not desired. Having your program end abnormally will never be a requirement of any application you develop. Exceptions are errors that only occur during the execution of a program. As previously mentioned, if an exception is not handled, the execution of the program will abnormally end. Exceptions are generated when an illegal operation takes place. An example of this would be to perform division by zero. Exceptions also occur when invoking methods. Usually methods written by another programmer. An example of this would be trying to parse non-numeric data to a numeric type. What is an Exception? . An exception is an object. This means that an exception is an instance of a class. All exceptions derive from the base class System.Exception. There are many exception types that are defined in the framework of most OOP languages. All these exceptions types will derive directly or indirectly from the Exception class. Flow of Code . When an exception happens, two things take place: . | An instance of an exception is created. | The exception is thrown down the Execution Call Stack. | . When an exception is thrown down the method call stack, the normal flow of the code does not happen. This means that when a exception occurs, no code will execute. As the exception traverses down the call stack, the run-time is looking for the exception to be handled. If the exception is handled at some point in the execution call stack, they flow of code is regained. If run-time makes it to the bottom of the execution call stack and does not find code to handle the exception, the program will terminate. Execution Call Stack . The Execution Call Stack, or just call stack, keeps track of each active method and where a method should return to when it finishes executing. When a method is invoked (called), it is added (pushed on) to the call stack. The first method on the call stack is always the Main method. When a method completes, the method is removed from (popped off) the call stack, and execution continues where the previous method left off. The program ends when the last method (Main) is removed from the call stack. This sample program has several methods. Each method has at least two statements. The first statement prints a message to indicate the method has been added to the stack. The last statement prints a message to indicate the method has been removed from the stack. internal class Program { static void Main(String[] args) { Console.WriteLine(\"Main - Added to the call stack.\"); MethodB(); MethodC(); MethodD(); MethodE(); Console.WriteLine(\"Main - Removed from the call stack.\"); } public static void MethodA(String message) { Console.WriteLine(\"MethodA - Added to the call stack.\"); Console.WriteLine(\"MethodA - Removed from the call stack.\"); } public static void MethodB() { Console.WriteLine(\"MethodB - Added to the call stack.\"); Console.WriteLine(\"MethodB - Removed from the call stack.\"); } public static void MethodC() { Console.WriteLine(\"MethodC - Added to the call stack.\"); MethodB(); Console.WriteLine(\"MethodC - Removed from the call stack.\"); } public static String MethodD() { Console.WriteLine(\"MethodD - Added to the call stack.\"); MethodC(); Console.WriteLine(\"MethodD - Removed from the call stack.\"); return \"Hello World\"; } public static void MethodE() { Console.WriteLine(\"MethodE - Added to the call stack.\"); MethodA(MethodD()); Console.WriteLine(\"MethodE - Removed from the call stack.\"); } } . This simple application demonstrates the call stack. You can see that the main method is the first method in the call stack and is not removed until the very end. Each time a method is invoked, it becomes active and is added to the call stack and is not removed until all other active methods added after it have been completed and removed. Output: . Main - Added to the call stack. MethodB - Added to the call stack. MethodB - Removed from the call stack. MethodC - Added to the call stack. MethodB - Added to the call stack. MethodB - Removed from the call stack. MethodC - Removed from the call stack. MethodD - Added to the call stack. MethodC - Added to the call stack. MethodB - Added to the call stack. MethodB - Removed from the call stack. MethodC - Removed from the call stack. MethodD - Removed from the call stack. MethodE - Added to the call stack. MethodD - Added to the call stack. MethodC - Added to the call stack. MethodB - Added to the call stack. MethodB - Removed from the call stack. MethodC - Removed from the call stack. MethodD - Removed from the call stack. MethodA - Added to the call stack. MethodA - Removed from the call stack. MethodE - Removed from the call stack. Main - Removed from the call stack. ",
    "url": "http://localhost:8888/adev2008/csharp-oop/exceptions/#understanding-exceptions",
    "relUrl": "/adev2008/csharp-oop/exceptions/#understanding-exceptions"
  },"131": {
    "doc": "Exceptions",
    "title": "Unhandled Exceptions",
    "content": "When an exception occurs, it will be generated (thrown) in the method currently at the top of the stack. Execution of the code will stop. The run-time will evaluate each method in the call stack to determine if the exception is handled. If it is handled, execution of code will continue at that point in the call stack. If the exception is not handled at any point in the call stack, the program will terminate. If the implementation of MethodB() is updated: . public static void MethodB() { Console.WriteLine(\"MethodB - Added to the call stack.\"); // This line will generate an exception double.Parse(\"Hello\"); Console.WriteLine(\"MethodB - Removed from the call stack.\"); } . Output: . Main - Added to the call stack. MethodB - Added to the call stack. Unhandled Exception: System.FormatException: Input string was not in a correct format. at System.Number.ParseDouble(String value, NumberStyles options, NumberFormatInfo numfmt) at System.Double.Parse(String s) at ADEV.Module2.App.Program.MethodB() in C:\\source\\ADEV.Module2.App\\Program.cs:line 41 at ADEV.Module2.App.Program.Main(String[] args) in C:\\source\\ADEV.Module2.App\\Program.cs:line 15 . You can see from the output of this program, that the program does not end properly. Had it ended properly, you would see the Main() method removed from the call stack. You can also see that MethodB() also did not complete properly, as it too was not removed from the call stack. Exceptions interrupt the normal flow a program. The program ends with information printed about the exception that was generated. This information can be intimidating to read at first. The more you mistakes you make, the more times you’ll read it. The more you read it, the better you’ll get at understanding it. You can see that the type of exception was FormatException. The data that caused the exception was the String \"Hello\". The text after this line displays the stack trace. The stack trace shows us the methods that were called, in the order they were added to the call stack, from main to the method where the exception was generated. As your programs become more complicated, the stack trace is essential information for fixing defects. Unhandled Exceptions In Visual Studio . When executing your program in Visual Studio, unhandled exceptions will stop the execution of the program and the statement that caused the exception is highlighted. The callout box seen in the image above, shows the type of exception, exception message, and the stack trace. Read all of this before stopping the execution of the program. ",
    "url": "http://localhost:8888/adev2008/csharp-oop/exceptions/#unhandled-exceptions",
    "relUrl": "/adev2008/csharp-oop/exceptions/#unhandled-exceptions"
  },"132": {
    "doc": "Exceptions",
    "title": "Handling Exceptions",
    "content": "An exception is handled using a try...catch structure. Generally speaking, you would put the statement that would potentially generate the exception within a try block. If the exception is generated, the exception is caught by the catch statement and execution of the code continues from the catch block. public static void MethodB() { Console.WriteLine(\"MethodB - Added to the call stack.\"); try { // This line will generate an exception double.Parse(\"Hello\"); } catch (FormatException) { Console.WriteLine(\"Failed to parse the data to a double.\"); } Console.WriteLine(\"MethodB - Removed from the call stack.\"); } . In almost all cases, it is necessary to include the exception type in the catch statement. Although it can be omitted, it would catch all exceptions. This may sound great in theory, but would hide potential problems in your code. Output: . Main - Added to the call stack. MethodB - Added to the call stack. Failed to parse the data to a double. MethodB - Removed from the call stack. MethodC - Added to the call stack. MethodB - Added to the call stack. Failed to parse the data to a double. MethodB - Removed from the call stack. MethodC - Removed from the call stack. MethodD - Added to the call stack. MethodC - Added to the call stack. MethodB - Added to the call stack. Failed to parse the data to a double. MethodB - Removed from the call stack. MethodC - Removed from the call stack. MethodD - Removed from the call stack. MethodE - Added to the call stack. MethodD - Added to the call stack. MethodC - Added to the call stack. MethodB - Added to the call stack. Failed to parse the data to a double. MethodB - Removed from the call stack. MethodC - Removed from the call stack. MethodD - Removed from the call stack. MethodA - Added to the call stack. MethodA - Removed from the call stack. MethodE - Removed from the call stack. Main - Removed from the call stack. It is important to understand the requirements of the code you are writing, as this determines where the try...catch block is coded. The try...catch block is always coded where the exception is to be handled. In this updated version of the program, the exception is being handled in the Main() method, which is lower in the call stack. internal class Program { static void Main(String[] args) { Console.WriteLine(\"Main - Added to the call stack.\"); try { MethodB(); MethodC(); MethodD(); MethodE(); } catch (FormatException) { Console.WriteLine(\"Failed to parse the data to a double.\"); } Console.WriteLine(\"Main - Removed from the call stack.\"); } public static void MethodA(String message) { Console.WriteLine(\"MethodA - Added to the call stack.\"); Console.WriteLine(\"MethodA - Removed from the call stack.\"); } public static void MethodB() { Console.WriteLine(\"MethodB - Added to the call stack.\"); // This line will generate an exception double.Parse(\"Hello\"); Console.WriteLine(\"MethodB - Removed from the call stack.\"); } public static void MethodC() { Console.WriteLine(\"MethodC - Added to the call stack.\"); MethodB(); Console.WriteLine(\"MethodC - Removed from the call stack.\"); } public static String MethodD() { Console.WriteLine(\"MethodD - Added to the call stack.\"); MethodC(); Console.WriteLine(\"MethodD - Removed from the call stack.\"); return \"Hello World\"; } public static void MethodE() { Console.WriteLine(\"MethodE - Added to the call stack.\"); MethodA(MethodD()); Console.WriteLine(\"MethodE - Removed from the call stack.\"); } } . You can see from the output below that the result is very different from when the exception was handled in MethodB(). Output: . Main - Added to the call stack. MethodB - Added to the call stack. Failed to parse the data to a double. Main - Removed from the call stack. If the code you are trying to execute has the potential to generate multiple types of exceptions, multiple catch statements can be defined beneath the try block. try { } catch (FormatException) { } catch (ArgumentOutOfRangeException) { } . ",
    "url": "http://localhost:8888/adev2008/csharp-oop/exceptions/#handling-exceptions",
    "relUrl": "/adev2008/csharp-oop/exceptions/#handling-exceptions"
  },"133": {
    "doc": "Exceptions",
    "title": "Referencing Handled Exceptions",
    "content": "If you need to obtain information about a handled exception, you can declare a variable to reference the exception. try { } catch (FormatException exception) { Log.WriteLine(excpetion.StackTrace); } . The scope of the variable is limited to the catch block. ",
    "url": "http://localhost:8888/adev2008/csharp-oop/exceptions/#referencing-handled-exceptions",
    "relUrl": "/adev2008/csharp-oop/exceptions/#referencing-handled-exceptions"
  },"134": {
    "doc": "Exceptions",
    "title": "Anticipating Exceptions",
    "content": ". By reading the documentation for a method you are calling, you can determine if there is a potential for an exception to occur. If a method generates an exception, a section with the heading “Exceptions” will exists. The documentation will list the type of exceptions that are thrown and what circumstances need to occur for the exception to be thrown. System exceptions are also documented, but can be found in explanations about how the language works. For example, the DivideByZeroException is generated when using the division (/) operator and the second operand is a zero. This exception doesn’t happen when you invoke a method. ",
    "url": "http://localhost:8888/adev2008/csharp-oop/exceptions/#anticipating-exceptions",
    "relUrl": "/adev2008/csharp-oop/exceptions/#anticipating-exceptions"
  },"135": {
    "doc": "Exceptions",
    "title": "Common .NET Exception Types",
    "content": "Exceptions are types that derive from the System.Exception class. The .NET Framework includes many exceptions types. Here are some common exceptions: . | ArgumentException - Thrown when any argument is invalid. | ArgumentNullException - Thrown when an argument is null. | ArgumentOutOfRangeException - Thrown when an argument value is out of the intended range. | FormatException - Thrown when an argument does not meet the format specifications intended by the method. | IndexOutOfRangeException - Thrown when you attempt to index an array using an index that is less than zero or greater than the length - 1. | InvalidCastException - Thrown when an explicit conversion from a base type or interface to a derived type fails. | NullReferenceException - Thrown when a null reference is used. | SystemException - Generated by the CLR. | . Notable exception members: . | Message - Gets a message that describes the exception. | StackTrace - Gets a string representation of the frames in the call stack. | . ",
    "url": "http://localhost:8888/adev2008/csharp-oop/exceptions/#common-net-exception-types",
    "relUrl": "/adev2008/csharp-oop/exceptions/#common-net-exception-types"
  },"136": {
    "doc": "Exceptions",
    "title": "Generating Exceptions",
    "content": "When developing code, mostly when developing data types, you will at some point need to generate an exception. Generating exceptions in your code helps another develop using your code by letting them know that they’ve done something incorrectly. To demonstration this, analyze the following code: . public class Person { private decimal amountOfMoney; public decimal AddMoney(decimal amount) { this.amountOfMoney += amount; return this.amountOfMoney; } } . If someone using AddMoney(decimal) method passes a negative numeric value as an argument, the method will not calculate the amountOfMoney as intended. It should be noted that there is no way for the developer coding the AddMoney(decimal) to prevent a negative numeric value as an argument. You are probably already thinking that this can be avoided by using a selection, and you wouldn’t be wrong. public class Person { private decimal amountOfMoney; public decimal AddMoney(decimal amount) { if(amount &lt; 0) { } this.amountOfMoney += amount; return this.amountOfMoney; } } . The question is, what do you do when you’ve determined the amount is a negative value? . Newer programmers would usually want to print an error message, telling the user that something went wrong. if(amount &lt; 0) { Console.WriteLine(\"Amount cannot be a negative value.\"); } . There is a few problems with this approach: . | If the application is not a Console Application, this message would not be visible and would be overlooked. | Seeing as though the message is being printed to the user, this message could be missed by the developer of the Person class. | Because the code execution would continue after this selection, the statement amount = 0; would be needed to avoid a logic error. | . The correct approach would be to generate an exception. Since it is required that the amount parameter be a zero or positive numeric value, a ArgumentOutOfRangeException would be generated when the amount is negative. Generating an exception takes two steps: . | Generate an instance of an exception class. | throw the exception instance. | . public class Person { private decimal amountOfMoney; public decimal AddMoney(decimal amount) { if(amount &lt; 0) { ArgumentOutOfRangeException exception; exception = new ArgumentOutOfRangeException(\"amount\", \"The argument cannot be less than zero.\"); throw exception; } this.amountOfMoney += amount; return this.amountOfMoney; } } . When the code execution performs the throw statement, the flow of code is interrupted and the run-time will traverse the call stack to determine if the exception is handled. ",
    "url": "http://localhost:8888/adev2008/csharp-oop/exceptions/#generating-exceptions",
    "relUrl": "/adev2008/csharp-oop/exceptions/#generating-exceptions"
  },"137": {
    "doc": "Exceptions",
    "title": "Documentation",
    "content": "When a method or property contains code that potentially throws an exception, information about the exception must be documented. When XML documentation is generated, Visual Studio does not parse the implementation of the unit, only its declaration. Therefore, you must manually add the XML to the documentation for things like exceptions. Exceptions are documented in an &lt;exception&gt;...&lt;/exception&gt; element. The documentation will include only one exception element per exception type generated in the method or property.The exception element will include one attribute, called cref, that is equal to the fully qualified name of the exception data type. The data within the element is the description of the situation(s) when that exception is thrown in the unit. The text typically starts with “Thrown when”. Check out documentation samples . ",
    "url": "http://localhost:8888/adev2008/csharp-oop/exceptions/#documentation",
    "relUrl": "/adev2008/csharp-oop/exceptions/#documentation"
  },"138": {
    "doc": "Exceptions",
    "title": "Testing Exceptions",
    "content": "The sample code below demonstrates how you can test exceptions in a command-line program. class Program { static void Main(string[] args) { Console.WriteLine(\"Testing method AddMoney(decimal)\"); Console.WriteLine(\"Test 1\"); AddMoney_AmountBelowZero_ExceptionThrown(); Console.Write(\"Press any key to continue...\"); Console.ReadKey(); } private static void AddMoney_AmountBelowZero_ExceptionThrown() { Console.WriteLine(\"Expected parameter: amount\"); Console.WriteLine(\"Expected message: The argument cannot be less than zero.\"); try { Person target = new Person(); target.AddMoney(-1000); } catch (ArgumentOutOfRangeException exception) { Console.WriteLine(\"Actual parameter: {0}\", exception.ParamName); Console.WriteLine(\"Actual message: {0}\", exception.Message); } } } . ",
    "url": "http://localhost:8888/adev2008/csharp-oop/exceptions/#testing-exceptions",
    "relUrl": "/adev2008/csharp-oop/exceptions/#testing-exceptions"
  },"139": {
    "doc": "Exceptions",
    "title": "Further Reading",
    "content": ". | Exceptions and Exception Handling | . ",
    "url": "http://localhost:8888/adev2008/csharp-oop/exceptions/#further-reading",
    "relUrl": "/adev2008/csharp-oop/exceptions/#further-reading"
  },"140": {
    "doc": "Form Class",
    "title": "Form Class",
    "content": ". | prefix | ? | . ",
    "url": "http://localhost:8888/adev2008/windows-forms-apps/form-class/",
    "relUrl": "/adev2008/windows-forms-apps/form-class/"
  },"141": {
    "doc": "Home",
    "title": "Programming 2 Course Notes",
    "content": " ",
    "url": "http://localhost:8888/#programming-2-course-notes",
    "relUrl": "/#programming-2-course-notes"
  },"142": {
    "doc": "Home",
    "title": "Learning Outcomes",
    "content": ". | Explain the .NET application architecture. | Use Microsoft Visual Studio to develop applications. | Develop a class library in the C# programming language. | Implement and handle exceptions. | Demonstrate debugging and testing strategies including unit testing. | Develop event driven Windows applications. | Develop applications using various types of collections. | Process data from a variety of sources | . ",
    "url": "http://localhost:8888/#learning-outcomes",
    "relUrl": "/#learning-outcomes"
  },"143": {
    "doc": "Home",
    "title": "Other Resources",
    "content": ". | Check out the course on Learn for projects, assignments and other learning material. | . ",
    "url": "http://localhost:8888/#other-resources",
    "relUrl": "/#other-resources"
  },"144": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "http://localhost:8888/",
    "relUrl": "/"
  },"145": {
    "doc": "Inheritance",
    "title": "Inheritance",
    "content": " ",
    "url": "http://localhost:8888/adev2008/csharp-oop/inheritance/",
    "relUrl": "/adev2008/csharp-oop/inheritance/"
  },"146": {
    "doc": "Inheritance",
    "title": "Table of Contents",
    "content": ". | Declaring Derived Classes | Invoking Base Class Constructors | Virtual Methods and Properties | Method and Property Overriding | Abstract Classes and Members | Class Diagram | Further Reading | . You learned in the previous level of programming that Inheritance enables you to create new classes that are based on another class. Inheritance allows you to reuse, extend and modify the behaviors of a class. The class that is being inherited from is called the Base Class. The class that is extending the base class is the derived class. Like Java, a class can only directly extend from one other class. ",
    "url": "http://localhost:8888/adev2008/csharp-oop/inheritance/#table-of-contents",
    "relUrl": "/adev2008/csharp-oop/inheritance/#table-of-contents"
  },"147": {
    "doc": "Inheritance",
    "title": "Declaring Derived Classes",
    "content": "public class Employee { } public class CommissionEmployee : Employee { } . The : symbol is used to indicate that a class derives from another class. In the example above, the CommissionEmployee class inherits from the Employee class. ",
    "url": "http://localhost:8888/adev2008/csharp-oop/inheritance/#declaring-derived-classes",
    "relUrl": "/adev2008/csharp-oop/inheritance/#declaring-derived-classes"
  },"148": {
    "doc": "Inheritance",
    "title": "Invoking Base Class Constructors",
    "content": "When you covered inheritance in the previous level of programming, you learned that a base class constructor must always be invoked by a derived class constructor. Depending how the base class is coded, you may be required to explicitly invoke a base class constructor. public class Employee { public string Name { get; private set; } public Employee(string name) { this.Name = name; } } public class CommissionEmployee : Employee { public CommissionEmployee(string name) : base(name) { } } . In the above example code, you can see the call to the base class constructor using the base keyword. This statement is coded on the same line as the declaration of the constructor, separated by the : symbol. When a base class is defined with a Default Constructor or a constructor with no parameters, the call to the base class constructor can happen implicitly. If you are receiving the “CS7036: There is no argument given that corresponds to the required formal parameter…”, it is likely you are not invoking the base class constructor when you should be doing this explicitly. ",
    "url": "http://localhost:8888/adev2008/csharp-oop/inheritance/#invoking-base-class-constructors",
    "relUrl": "/adev2008/csharp-oop/inheritance/#invoking-base-class-constructors"
  },"149": {
    "doc": "Inheritance",
    "title": "Virtual Methods and Properties",
    "content": "In Java, all methods are declared as virtual by default. A method must be declared as virtual to allow it to be overridden in a derived class. In C#, methods and properties are not virtual by default. To allow a method or property to be overridden, you must declare it using the virtual keyword. public class Employee { public virtual string Name { get; private set; } public virtual decimal GetPay() { } } . ",
    "url": "http://localhost:8888/adev2008/csharp-oop/inheritance/#virtual-methods-and-properties",
    "relUrl": "/adev2008/csharp-oop/inheritance/#virtual-methods-and-properties"
  },"150": {
    "doc": "Inheritance",
    "title": "Method and Property Overriding",
    "content": "To override a method or property, you must use the override keyword. public class CommissionEmployee : Employee { public override string Name { get { } } public override decimal GetPay() { } } . When you want to include the base class implementation in the derived class version of the method, you can invoke it using the base keyword. public class CommissionEmployee : Employee { public override decimal GetPay() { return base.GetPay() * this.CommissionRate; } } . Omitting the override keyword will not cause a syntax error, but will not result in method overriding. ",
    "url": "http://localhost:8888/adev2008/csharp-oop/inheritance/#method-and-property-overriding",
    "relUrl": "/adev2008/csharp-oop/inheritance/#method-and-property-overriding"
  },"151": {
    "doc": "Inheritance",
    "title": "Abstract Classes and Members",
    "content": "When a class is defined solely for the purposes of being a base class, you will declare the class using the abstract keyword. public abstract class Employee { } . Abstract classes cannot be instantiated on their own. Methods and properties that cannot be implemented in the base class, are declared using the abstract keyword and do not have a code block. public abstract class Employee { public abstract decimal GetPay(); } . Class members declared as abstract must be implemented in the derived concrete class. public class CommissionEmployee : Employee { public override decimal GetPay() { } } . If the GetPay() method was coded as a property, it would look like: . public abstract class Employee { public abstract decimal Pay { get; } } public class CommissionEmployee : Employee { public override decimal Pay { get { } } } . ",
    "url": "http://localhost:8888/adev2008/csharp-oop/inheritance/#abstract-classes-and-members",
    "relUrl": "/adev2008/csharp-oop/inheritance/#abstract-classes-and-members"
  },"152": {
    "doc": "Inheritance",
    "title": "Class Diagram",
    "content": "In a UML Class Diagram, abstract classes and members are indicated by italicizing in the text. Employee . - identificationNumber : int - name : string + &lt;&lt;Property&gt;&gt; IdentificationNumber : int + &lt;&lt;Property&gt;&gt; Name : string . + Employee(identificationNumber : int, name : string) + Employee(identificationNumber : int) + GetPay() : decimal . ",
    "url": "http://localhost:8888/adev2008/csharp-oop/inheritance/#class-diagram",
    "relUrl": "/adev2008/csharp-oop/inheritance/#class-diagram"
  },"153": {
    "doc": "Inheritance",
    "title": "Further Reading",
    "content": ". | Inheritance | Virtual | Abstract | . ",
    "url": "http://localhost:8888/adev2008/csharp-oop/inheritance/#further-reading",
    "relUrl": "/adev2008/csharp-oop/inheritance/#further-reading"
  },"154": {
    "doc": "Intro to .NET, C# & VS",
    "title": "Introduction to .NET, C# and Visual Studio",
    "content": "The section will help you answer the following questions: . | What is .NET?  | What is C# and what are the basics of the language? | What is Visual Studio, and how do I use it to create an application? | . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs#introduction-to-net-c-and-visual-studio",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs#introduction-to-net-c-and-visual-studio"
  },"155": {
    "doc": "Intro to .NET, C# & VS",
    "title": "Learning Objectives",
    "content": ". | Describe the structure of the .NET Framework.  | Create a Visual Studio Solution/Project. | Develop source code in C# for classes and console applications. | Develop source code for Enumerations and Structures. | Develop documentation for C# source code. | . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs#learning-objectives",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs#learning-objectives"
  },"156": {
    "doc": "Intro to .NET, C# & VS",
    "title": "Intro to .NET, C# & VS",
    "content": " ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs"
  },"157": {
    "doc": "Introduction to .NET",
    "title": "Introduction to .NET",
    "content": " ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/introduction-to-dotnet/",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/introduction-to-dotnet/"
  },"158": {
    "doc": "Introduction to .NET",
    "title": "Table of Contents",
    "content": ". | What is .NET? | What is the .NET Framework? | How Does it Work? . | Common Language Runtime (CLR) | .NET Framework Class Library | The Architecture | . | Developing .NET Framework Apps | Executing .NET Framework Apps | . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/introduction-to-dotnet/#table-of-contents",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/introduction-to-dotnet/#table-of-contents"
  },"159": {
    "doc": "Introduction to .NET",
    "title": "What is .NET?",
    "content": ".NET (pronounced “dot net”) is a free, cross-platform, open-source development platform. It is developed and maintained by Microsoft.NET is used to develope many types of applications.NET supports multiple languages, including C#, F# and Visual Basic. An application can be made up of source code from any supported language and will run natively on any compatible operating system.NET is a cross-platform .NET implementation mostly used for websites, servers and console applications on Windows, Linux, and Mac. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/introduction-to-dotnet/#what-is-net",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/introduction-to-dotnet/#what-is-net"
  },"160": {
    "doc": "Introduction to .NET",
    "title": "What is the .NET Framework?",
    "content": "The .NET Framework is the original implementation of .NET. It is a framework for developing desktop apps, websites, services, and more on Windows. The .NET Framework is not cross-platform and can only be used for developing applications for the Windows operating system. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/introduction-to-dotnet/#what-is-the-net-framework",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/introduction-to-dotnet/#what-is-the-net-framework"
  },"161": {
    "doc": "Introduction to .NET",
    "title": "How Does it Work?",
    "content": "The two major parts of the .NET Framework are the Common Language Runtime (CLR) and the .NET Framework Class Library. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/introduction-to-dotnet/#how-does-it-work",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/introduction-to-dotnet/#how-does-it-work"
  },"162": {
    "doc": "Introduction to .NET",
    "title": "Common Language Runtime (CLR)",
    "content": "The Common Language Runtime (CLR) manages the execution of .NET Framework applications. The CLR is very similar to how the Java Virtual Machine works in the Java architecture. The CLR provides services like garbage collection, thread management, type safety, exception handling and much more. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/introduction-to-dotnet/#common-language-runtime-clr",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/introduction-to-dotnet/#common-language-runtime-clr"
  },"163": {
    "doc": "Introduction to .NET",
    "title": ".NET Framework Class Library",
    "content": "The .NET Framework Class Library is set of Application Programming Interfaces (APIs) and data types a develop can use to develop applications. The Class Library is very similar to the library of classes offered to Java developers in the JDK. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/introduction-to-dotnet/#net-framework-class-library",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/introduction-to-dotnet/#net-framework-class-library"
  },"164": {
    "doc": "Introduction to .NET",
    "title": "The Architecture",
    "content": ". As mentioned above, .NET supports multiple languages. The advantage of this is that the source code that makes up an application can be written in various languages. When source code is compiled, it is compiled to a bytecode called Common Intermediate Language (CIL). Each language compiler will generate the same type of bytecode. For example, if you were to write a simple “Hello World” program in C#, and again in Visual Basic, each of these programs would compile to the same CIL. The CIL is stored in files called Assemblies. Assembly files end with the file extension .exe or .dll. This module will cover the .exe assembly. The .dll assembly is covered in the next module. During the execution of a .NET application, the CLR processes the CLI (a.k.a. managed code) from one or more assemblies to generate the machine code necessary to execute the instructions on the computers platform. This processes is referred to as Just-in-time (JIT) compiling. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/introduction-to-dotnet/#the-architecture",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/introduction-to-dotnet/#the-architecture"
  },"165": {
    "doc": "Introduction to .NET",
    "title": "Developing .NET Framework Apps",
    "content": "To develop a .NET Framework Application, you will need: . | A code editor that supports development of the .NET applications. The most common of which are Visual Studio Community and Visual Studio Code. | A compiler for the .NET supported programming language of choice. | . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/introduction-to-dotnet/#developing-net-framework-apps",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/introduction-to-dotnet/#developing-net-framework-apps"
  },"166": {
    "doc": "Introduction to .NET",
    "title": "Executing .NET Framework Apps",
    "content": "Whether you are a developer or not, executing programs written in .NET requires a Common Language Runtime for the platform of computer you running. If you are using the Windows operating system, it is very likely you already have a version of the framework installed. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/introduction-to-dotnet/#executing-net-framework-apps",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/introduction-to-dotnet/#executing-net-framework-apps"
  },"167": {
    "doc": "Introduction to .NET",
    "title": "Further Reading",
    "content": ". | .NET Framework - Overview | .NET Framework - Get Started | . References . | Video: What is .NET? | Figure 1: What is the .NET Framework? | . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/introduction-to-dotnet/#further-reading",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/introduction-to-dotnet/#further-reading"
  },"168": {
    "doc": "Loops",
    "title": "Loops",
    "content": " ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/loops/",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/loops/"
  },"169": {
    "doc": "Loops",
    "title": "Table of Contents",
    "content": ". | For Loop | Do While Loop | While Loop | ForEach Loop | Further Reading | . Loops allow you to repeat one or more statements. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/loops/#table-of-contents",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/loops/#table-of-contents"
  },"170": {
    "doc": "Loops",
    "title": "For Loop",
    "content": "const int Number = 10; // Prints the first twenty multiples of the number for(int i = 0; i &lt; 20; i++) { Console.Write(\"{0} \", i * Number); } . Output: . 0 10 20 30 40 50 60 70 80 90 100 110 110 120 130 140 150 160 170 180 190 . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/loops/#for-loop",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/loops/#for-loop"
  },"171": {
    "doc": "Loops",
    "title": "Do While Loop",
    "content": "int grade = -1; int sum = 0; int numberOfGrades = 0; do { Console.Write(\"Enter a grade (-1 to exit): \"); string input = Console.ReadLine(); grade = Int32.Parse(input); if (grade != -1) { sum += grade; numberOfGrades++; } } while (grade != -1); double average = (double)sum / numberOfGrades; Console.WriteLine(\"The average grade is {0}.\", Math.Round(average)); . Output: . Enter a grade (-1 to exit): 12 Enter a grade (-1 to exit): 23 Enter a grade (-1 to exit): 90 Enter a grade (-1 to exit): 89 Enter a grade (-1 to exit): 45 Enter a grade (-1 to exit): 78 Enter a grade (-1 to exit): 56 Enter a grade (-1 to exit): -1 The average grade is 56. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/loops/#do-while-loop",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/loops/#do-while-loop"
  },"172": {
    "doc": "Loops",
    "title": "While Loop",
    "content": ". Output: . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/loops/#while-loop",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/loops/#while-loop"
  },"173": {
    "doc": "Loops",
    "title": "ForEach Loop",
    "content": "int[] grades = {98, 34, 78, 45, 85}; string letterGrade = \"\"; foreach(int grade in grades) { if(grade &gt;= 90) { letterGrade = \"A+\"; } else if (grade &gt;= 80) { letterGrade = \"A\"; } else if (grade &gt;= 75) { letterGrade = \"B+\"; } else if (grade &gt;= 60) { letterGrade = \"B\"; } else if (grade &gt;= 65) { letterGrade = \"C+\"; } else if (grade &gt;= 60) { letterGrade = \"C\"; } else if (grade &gt;= 50) { letterGrade = \"D\"; } else { letterGrade = \"F\"; } Console.WriteLine(letterGrade); } . Output: . A+ F B+ F A . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/loops/#foreach-loop",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/loops/#foreach-loop"
  },"174": {
    "doc": "Loops",
    "title": "Further Reading",
    "content": ". | Iteration Statements | . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/loops/#further-reading",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/loops/#further-reading"
  },"175": {
    "doc": "Math",
    "title": "Math",
    "content": " ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/math/",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/math/"
  },"176": {
    "doc": "Math",
    "title": "Table of Contents",
    "content": ". | Arithmetic Operators | Math Class | Further Reading | . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/math/#table-of-contents",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/math/#table-of-contents"
  },"177": {
    "doc": "Math",
    "title": "Arithmetic Operators",
    "content": "In C#, you can expect to use all the same arithmetic operators you used in Java: . | Binary: + (Addition), - (Subtraction), * (Multiplication), / (Division), % (Reminder) | Unary: ++ (Increment), -- (Decrement) | . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/math/#arithmetic-operators",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/math/#arithmetic-operators"
  },"178": {
    "doc": "Math",
    "title": "Math Class",
    "content": "The System.Math class is used for common mathematical functions not easily done with the arithmetic operators. double radius = 4.5; double area = Math.PI * Math.Pow(radius, 2); Console.WriteLine(\"Area: {0}\", area); . Output: . Area: 63.6172512351933 . It’s also recommended to familiarize yourself with the Math class members for the programming language you are working with. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/math/#math-class",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/math/#math-class"
  },"179": {
    "doc": "Math",
    "title": "Further Reading",
    "content": ". | Arithmetic Operators | Math Class Documentation | . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/math/#further-reading",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/math/#further-reading"
  },"180": {
    "doc": "Messagebox Class",
    "title": "Messagebox Class",
    "content": ". | Control | | . ",
    "url": "http://localhost:8888/adev2008/windows-forms-apps/messagebox-class/",
    "relUrl": "/adev2008/windows-forms-apps/messagebox-class/"
  },"181": {
    "doc": "Method Tests",
    "title": "Method Tests",
    "content": " ",
    "url": "http://localhost:8888/adev2008/unit-testing/method-tests/",
    "relUrl": "/adev2008/unit-testing/method-tests/"
  },"182": {
    "doc": "Method Tests",
    "title": "Table of Contents",
    "content": ". | Void Methods | Non-Void Methods | . ",
    "url": "http://localhost:8888/adev2008/unit-testing/method-tests/#table-of-contents",
    "relUrl": "/adev2008/unit-testing/method-tests/#table-of-contents"
  },"183": {
    "doc": "Method Tests",
    "title": "Void Methods",
    "content": "Test Case: . | # | Test Case | Test Data | Expected | . | 3 | Add money | Initial amount of money: 100, Parameter amount: 60 | Amount of money state: 160 | . Testing Goal: Invoke the method and verify the object’s state. [TestMethod] public void AddMoney_PositiveAmount_StateUpdated() { // Arrange string name = \"Kenny\"; decimal amountOfMoney = 100; Person person = new Person(name, amountOfMoney); // Act person.AddMoney(60); decimal expected = 160; // Reflection PrivateObject target = new PrivateObject(person); // Obtain object state decimal actual = (decimal)target.GetField(\"amountOfMoney\"); // Assert Assert.AreEqual(expected, actual); } . Notes: . | The outcome of this method is to change the state and is verified by using PrivateObject. | . ",
    "url": "http://localhost:8888/adev2008/unit-testing/method-tests/#void-methods",
    "relUrl": "/adev2008/unit-testing/method-tests/#void-methods"
  },"184": {
    "doc": "Method Tests",
    "title": "Non-Void Methods",
    "content": "Test Case: . | # | Test Case | Test Data | Expected | . | 1 | Return string representation of the Person | Initial name: Kenny, Initial amount of money: 123.45M | “Kenny - $123.45” | . Testing Goal: Obtain the value returned from the method. [TestMethod] public void ToString_ReturnsResult() { // Arrange string name = \"Kenny\"; decimal amountOfMoney = 123.45M; Person person = new Person(name, amountOfMoney); // Act string actual = person.ToString(); string expected = \"Kenny - $123.45\"; // Assert Assert.AreEqual(expected, actual); } . Notes: . | When a method returns a value, that value is captured to verify the test. | . ",
    "url": "http://localhost:8888/adev2008/unit-testing/method-tests/#non-void-methods",
    "relUrl": "/adev2008/unit-testing/method-tests/#non-void-methods"
  },"185": {
    "doc": "Methods",
    "title": "Methods",
    "content": " ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/methods/",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/methods/"
  },"186": {
    "doc": "Methods",
    "title": "Table of Contents",
    "content": ". | Program Methods | Methods For Objects | . C# methods work the same way they do in Java. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/methods/#table-of-contents",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/methods/#table-of-contents"
  },"187": {
    "doc": "Methods",
    "title": "Program Methods",
    "content": "If you are writing a method within a Program class: . namespace ADEV.Module1.Methods { internal class Program { static void Main(string[] args) { } static bool IsValidName(string name) { return name != null &amp;&amp; name.Length &gt; 1; } } } . Like Java, C# Console programs execute from a static context. All methods within the Program class must be declared as static. It is common for C# beginners to declare and define methods outside of the class block. If you are getting syntax errors declaring methods, double-check you’ve declared the method within the class block and not within the namespace or Main method block. To invoke the method: . static void Main(string[] args) { string studentName = \"Kenny\"; Console.WriteLine(IsValidName(studentName)) } . Because the IsValidName() method is within the same class, dot-notation is not required. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/methods/#program-methods",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/methods/#program-methods"
  },"188": {
    "doc": "Methods",
    "title": "Methods For Objects",
    "content": "Check out the Classes section of these notes. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/methods/#methods-for-objects",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/methods/#methods-for-objects"
  },"189": {
    "doc": "Microsoft Developer Network",
    "title": "Microsoft Developer Network",
    "content": " ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/msdn/",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/msdn/"
  },"190": {
    "doc": "Microsoft Developer Network",
    "title": "Table of Contents",
    "content": ". | Access API Documentation in Visual Studio | Further Reading | . The Microsoft Developer Network (MSDN) is a developer community providing API information and documentation. There are two ways you can access the MSDN: . | Using the link: The .NET API Browser | Directly from Visual Studio | . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/msdn/#table-of-contents",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/msdn/#table-of-contents"
  },"191": {
    "doc": "Microsoft Developer Network",
    "title": "Access API Documentation in Visual Studio",
    "content": ". | Click your cursor on a reference to the class you wish to read the documentation about. | Press the F1 key. This will open an instance of your default browser and load the documentation page within it. Depending on your keyboard, you may need to hold down the fn (Function) key when you press the F1 key. This method of looking up documentation works for more than just classes. You can put your cursor on anything, like a method, and when you click F1 it will open the documentation for that item. | . Using F1 to jump to documentation will only work for Framework APIs. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/msdn/#access-api-documentation-in-visual-studio",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/msdn/#access-api-documentation-in-visual-studio"
  },"192": {
    "doc": "Microsoft Developer Network",
    "title": "Further Reading",
    "content": ". | The .NET Framework | C# | . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/msdn/#further-reading",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/msdn/#further-reading"
  },"193": {
    "doc": "MSTest",
    "title": "MSTest",
    "content": " ",
    "url": "http://localhost:8888/adev2008/unit-testing/mstest/",
    "relUrl": "/adev2008/unit-testing/mstest/"
  },"194": {
    "doc": "MSTest",
    "title": "Table of Contents",
    "content": ". | What is MSTest? | Creating an MSTest Project | Solution File Structure | Unit Test Class Standards | Add Unit Test Classes | . The quality of your code is directly effected by how well you’ve tested it. The process of testing software is often referred to as Unit Testing. It’s called unit testing because the software being tested is broken down into testable behaviors known as units. Typically, the smallest unit of testable code is a method. In C#, this would also include property accessors. The goal of unit testing is to execute each unit to verify its behavior results in the expected way based on the requirement of the unit. Prior to this lesson, you preformed unit testing. You would have done this in two ways: . | Execute a program many times to determine all possible outcomes are met. | Write a program that tests another class. The program would include methods to test each outcome of the methods within the class you are testing. | . These techniques are acceptable when you are beginning your developer journey. But they do have drawbacks: . | Testing a program typically requires human interaction. | Results are verified by the tester comparing values. This can often lead to oversights. | Not able to test methods independently in many cases due to inaccessible fields. | . ",
    "url": "http://localhost:8888/adev2008/unit-testing/mstest/#table-of-contents",
    "relUrl": "/adev2008/unit-testing/mstest/#table-of-contents"
  },"195": {
    "doc": "MSTest",
    "title": "What is MSTest?",
    "content": "MSTest is a Unit Testing Framework (UTF). It helps in writing effective unit tests. The UTF includes software tools that support writing and running of tests, that includes a foundation to build tests and functionality to execute tests and report the results. ",
    "url": "http://localhost:8888/adev2008/unit-testing/mstest/#what-is-mstest",
    "relUrl": "/adev2008/unit-testing/mstest/#what-is-mstest"
  },"196": {
    "doc": "MSTest",
    "title": "Creating an MSTest Project",
    "content": "Creating a Class Library project follows the same steps as a Console Application, except that you will choose a different project template. When you get to the Create a new project window, the project type you want to choose is called “Unit Test Project (.NET Framework)”. You can use the search to filter the list. ",
    "url": "http://localhost:8888/adev2008/unit-testing/mstest/#creating-an-mstest-project",
    "relUrl": "/adev2008/unit-testing/mstest/#creating-an-mstest-project"
  },"197": {
    "doc": "MSTest",
    "title": "Solution File Structure",
    "content": "At this point you may have more than one Visual Studio solution stored in this location. Read the directories careful to determine the one you are looking for. Solution Directory . The solution directory contains: . | Project Directory - You will see one directory for each project in the solution. New solutions will only contain one project and thus will have one project directory. | packages - This directory can be ignored. We won’t be using it in this course. | Solution File (.sln) - A file that ends with the file extension .sln. The .sln file contains information the Visual Studio environment needs to find and load the solution’s associated projects and resources. | . Project Directory . The project directory contains: . | bin Directory - Where the resulting files of a successful project build are stored. | obj Directory - This directory can be ignored. We won’t be using it in this course. | Properties Directory - This is another directory that can be ignored. | MS Build File (.csproj) File - The MSBuild file for the Visual Studio project. | packages.config - An XML file that can be used to store settings for the test project. | UnitTest1.cs - This file contains a class called UnitTest1 and is created by default because of the project template that was chosen when creating the project. | . UnitTest1 is not an appropriate name for a class. You should rename this file and the class identifier within it. ",
    "url": "http://localhost:8888/adev2008/unit-testing/mstest/#solution-file-structure",
    "relUrl": "/adev2008/unit-testing/mstest/#solution-file-structure"
  },"198": {
    "doc": "MSTest",
    "title": "Unit Test Class Standards",
    "content": "Unit Test class identifiers follow the same standards as any other class and are named in the following format: . ClassYouAreTestingTests . The identifier will begin with the name of the class you are testing followed by the word “Tests”. For example, if you are testing a class called “Student”, the unit test class would be called “StudentTests”. ",
    "url": "http://localhost:8888/adev2008/unit-testing/mstest/#unit-test-class-standards",
    "relUrl": "/adev2008/unit-testing/mstest/#unit-test-class-standards"
  },"199": {
    "doc": "MSTest",
    "title": "Add Unit Test Classes",
    "content": "To add additional unit test classes to your unit test project, add an item to your project as you’ve done for other projects. In the Add New Item dialog window, select Test from the template categories on the left hand side of the window. Then choose the Basic Unit Test template. Give the source code file a name based on the unit test class standards above. The Basic Unit Test template will use the file name as the class identifier. ",
    "url": "http://localhost:8888/adev2008/unit-testing/mstest/#add-unit-test-classes",
    "relUrl": "/adev2008/unit-testing/mstest/#add-unit-test-classes"
  },"200": {
    "doc": "Namespaces",
    "title": "Namespaces",
    "content": " ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/namespaces/",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/namespaces/"
  },"201": {
    "doc": "Namespaces",
    "title": "Table of Contents",
    "content": ". | Declaring Namespaces | Fully Qualified Identifiers | Naming Conventions | Nested Namespaces | using Directive | Name Collision | Further Reading | . The .NET Framework is made up of hundreds of classes, enumerations, delegates and other types. You could imagine that the Framework could be a very confusing thing to use if it wasn’t organized in a logical manner. Think of the Framework like library in your neighborhood. A library is filled with books and other resources. To keep it simple, we can say a book represents a class. Now imagine the library had 5000 books. Without proper organization, it would be difficult to find the book you are looking for. We would also have to consider that some books may make reference to other books in the library. Also, imagine the librarian having to manage to catalogue with additions and changes. When developing applications (or anything really), it is very important to be organized. It is the most efficient way to complete any programming project. The .NET Framework is organized by using Namespaces. Namespaces serve two purposes: . | Organizes related classes (and other types). | Defines a scope for classes (preventing Name Collisions) and methods. | . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/namespaces/#table-of-contents",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/namespaces/#table-of-contents"
  },"202": {
    "doc": "Namespaces",
    "title": "Declaring Namespaces",
    "content": "When you create any class, enumeration, or other type, you will declare it within a namespace. namespace Education { public class Student { } } . In the sample code above, the Student class is declared within the Education Namespace. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/namespaces/#declaring-namespaces",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/namespaces/#declaring-namespaces"
  },"203": {
    "doc": "Namespaces",
    "title": "Fully Qualified Identifiers",
    "content": "When you declare a class, or any other type, the actual identifier for the class includes the namespace. This is referred to as the Fully Qualified name of the class. For the Student class above, the fully qualified name would be Education.Student. In order to use the class in another code context, you’d have to fully qualify the identifier. Education.Student student; student = new Education.Student(); . This works for classes in the .NET Framework Application Programming Interface (API). In a later topic you will be introduced to the Console class. The Console class is declared within the System namespace. It’s fully qualified name would be System.Console. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/namespaces/#fully-qualified-identifiers",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/namespaces/#fully-qualified-identifiers"
  },"204": {
    "doc": "Namespaces",
    "title": "Naming Conventions",
    "content": "Namespace identifiers must follow these naming conventions: . | Identifiers must start with a letter or underscore (_). | Use Pascal-casing (Example: ThisIsCapitalCase). | The identifier is descriptive of the types and other Namespaces within it. | Use of acronyms is accepted. | . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/namespaces/#naming-conventions",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/namespaces/#naming-conventions"
  },"205": {
    "doc": "Namespaces",
    "title": "Nested Namespaces",
    "content": "A namespace can be declared within another namespace. This allows you to define a hierarchy of types. namespace Education { namespace Grades { public class Grade { } } } . namespace Education { namespace Assessments { public class Exercises { } } } . In the two samples above, a namespace called Education is declared. The Education namespace has two sub-namespaces called Grades and Assessments. The above examples can be simplified to: . namespace Education.Grades { public class Grade { } } . namespace Education.Assessments { public class Exercises { } } . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/namespaces/#nested-namespaces",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/namespaces/#nested-namespaces"
  },"206": {
    "doc": "Namespaces",
    "title": "using Directive",
    "content": "The using directive allows you to access types without having to fully qualify them. The following code example declares a class within a deeply nested namespace. namespace Animalia.Chordata.Carnivora.Feliformia.Felidae.Felinae.Felis { public class Cat { } } . Using the fully qualified name would look like: . Animalia.Chordata.Carnivora.Feliformia.Felidae.Felinae.Felis.Cat pet; pet = new Animalia.Chordata.Carnivora.Feliformia.Felidae.Felinae.Felis.Cat(); . The using statement is coded at the beginning of the code and indicates namespaces you wish to use types from. using Animalia.Chordata.Carnivora.Feliformia.Felidae.Felinae.Felis; namespace Module1.Namespaces { public class Program { static void Main(string[] args) { Cat pet; pet = new Cat(); } } } . Namespaces are like packages in Java. Using statements are like import statements in Java. Unlike Java, using statements cannot reference a type. The following using statement would cause a syntax error.using Animalia.Chordata.Carnivora.Feliformia.Felidae.Felinae.Felis.Cat; . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/namespaces/#using-directive",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/namespaces/#using-directive"
  },"207": {
    "doc": "Namespaces",
    "title": "Name Collision",
    "content": "A Name Collision happens when you are using an identifier that is be resolved in one or more ways. Consider the following two classes: . namespace ADEV.MusicStore { public class Resource { } } . namespace TaskManagement { public class Resource { } } . We have two classes with the same identifier Resource. Let’s say we need to use both these namespaces in a program. using ADEV.MusicStore; using TaskManagement; namespace RRC.ADEV.CourseNotes.Module1 { internal class Program { static void Main(string[] args) { Resource thing; } } } . The statement Resource thing; would cause a syntax error, because Visual Studio will not know which Resource you are referring to. But because the type was declared within a namespace, we can avoid the naming conflict by using the namespace. TaskManagement.Resource thing; . It is not acceptable practice to change the name of a class (or other type) just to avoid a naming collision because you don’t want to deal with namespaces. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/namespaces/#name-collision",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/namespaces/#name-collision"
  },"208": {
    "doc": "Namespaces",
    "title": "Further Reading",
    "content": ". | Namespaces | Names of Namespaces | using Directive | . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/namespaces/#further-reading",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/namespaces/#further-reading"
  },"209": {
    "doc": "Object Browser",
    "title": "Object Browser",
    "content": "The Object Browser is a tool in Visual Studio that allows you to enumerate and examine classes in the .NET Framework class library and libraries you code yourself. This tool is very poorly named, as you cannot use this to actually browse objects. You can use this tool to quickly find information about classes (or other modules) and their members. Here is how you can use it: . You can open the Object Browser from the main menu by navigating to View &gt; Object Browser. The Object Browser has three panels: . To find a class, use the search box at the top of the Object Browser panel. You can also expand the listed namespaces in the namespace panel. The namespace panel will only display namespaces for assemblies that are referenced in the project. When you have selected a class in the namespace panel, the member panel will populate with all the accessible members of that type. When you select a member in the members panel, the description panel will display documentation for the selected member. ",
    "url": "http://localhost:8888/adev2008/csharp-oop/object-browser/",
    "relUrl": "/adev2008/csharp-oop/object-browser/"
  },"210": {
    "doc": "Object Browser",
    "title": "Further Reading",
    "content": ". | Object Browser | . ",
    "url": "http://localhost:8888/adev2008/csharp-oop/object-browser/#further-reading",
    "relUrl": "/adev2008/csharp-oop/object-browser/#further-reading"
  },"211": {
    "doc": "Properties",
    "title": "Properties",
    "content": " ",
    "url": "http://localhost:8888/adev2008/csharp-oop/properties/",
    "relUrl": "/adev2008/csharp-oop/properties/"
  },"212": {
    "doc": "Properties",
    "title": "Table of Contents",
    "content": ". | Declaring and Defining Properties . | get Accessor | set Accessor | Expression Body Definition | Read-only Properties | . | Using Properties | Auto-Implemented Properties | Class Diagram | Further Reading | . In the previous level of programming, you learned that: . | fields define the attributes of objects of the type. | fields are declared with private access, following the Object-Oriented Programming principle of Encapsulation. | reading, writing and computing field values (object state) happens in accessor and mutator methods. | . public class Employee { private int identificationNumber; public int GetIdentificationNumber() { return this.identificationNumber; } public void SetIdentificationNumber(int identificationNumber) { this.identificationNumber = identificationNumber; } } . A C# property is a class member that provides a mechanism to read, write or compute the value of a private field. In many cases, properties eliminates the need for accessor and mutator methods. ",
    "url": "http://localhost:8888/adev2008/csharp-oop/properties/#table-of-contents",
    "relUrl": "/adev2008/csharp-oop/properties/#table-of-contents"
  },"213": {
    "doc": "Properties",
    "title": "Declaring and Defining Properties",
    "content": "A property is defined using get and set accessors: . public class Employee { private int identificationNumber; public int IdentificationNumber { get { return this.identificationNumber; } set { this.identificationNumber = value; } } } . get Accessor . To access an object’s state, a properties must include a get accessor. A get accessor can include any type of statements, but must have a return. get { return this.identificationNumber; } . set Accessor . To modify an object’s state, a property must include a set accessor. A set accessor can include any type or number of statements. Like an mutator method, to update the state, the field of the class will be assigned a new value. Because properties are not methods, there is no parameter to store the value to assign to the field. Rather, the keyword value is used to store the value assigned to the property. set { this.identificationNumber = value; } . Expression Body Definition . The implementation of a property’s accessor is often a single-line expression. When the accessor implementation is a single-line expression, the accessor can be defined using a =&gt; symbol followed by the expression to assign or retrieve from the property. public class Employee { private int identificationNumber; public int IdentificationNumber { get =&gt; this.identificationNumber; set =&gt; this.identificationNumber = value; } } . The return keyword is not used with an Expression Body Definition. Read-only Properties . Properties can be defined with one or two accessors: . | Read and Write: Access to both accessors. | Read-only: Only access to the get accessor. | Write-only: Only access to the set accessor. | . In the examples above, you seen how properties can be defined with both get and set accessors. If one of the accessors is not required, it can be omitted. public class Employee { private string name; public string Name { get =&gt; this.name; } } . This example defines the Name property as a read-only property. The property is considered read-only because without the set accessor a new state cannot be written to the object. Defining the property this way, the class itself won’t be able to set the property. If an accessor is only required within the class, the private accessor modifier can be used. public class Employee { private string name; public string Name { get =&gt; this.name; private set =&gt; this.name = value; } } . This example also defines the Name property as read-only, but the class itself will be able to set the property. It is very rare for a property to be Write-only. ",
    "url": "http://localhost:8888/adev2008/csharp-oop/properties/#declaring-and-defining-properties",
    "relUrl": "/adev2008/csharp-oop/properties/#declaring-and-defining-properties"
  },"214": {
    "doc": "Properties",
    "title": "Using Properties",
    "content": "Using properties is like using a public field. Assigning a value to the property invokes the set accessor. Using the property in all other expressions will invoke the get accessor. class Program { static void Main(string[] args) { Employee employee; employee = new Employee(); // Invokes the set accessor employee.IdentificationNumber = 5; // Invokes the get accessor Console.WriteLine(employee.IdentificationNumber); } } . ",
    "url": "http://localhost:8888/adev2008/csharp-oop/properties/#using-properties",
    "relUrl": "/adev2008/csharp-oop/properties/#using-properties"
  },"215": {
    "doc": "Properties",
    "title": "Auto-Implemented Properties",
    "content": "When the implementation of a property is only to assign a value or retrieve a value from a field without any additional logic, the property can be auto-implemented. An auto-implemented property’s accessors will not have a block. Also, a field (called a Backing Field) is automatically created for the class. When the class is compiled, a backing field and implementation is created for the property. public class Employee { public string Name { get; set; } } . You do not have access to the Backing Field. If you are required to declare a field within the class, you will not be able to auto-implement the associated property. The previous example is equivalent to: . public class Employee { private string name; public string Name { get { return this.name; } set { this.name = value; } } } . ",
    "url": "http://localhost:8888/adev2008/csharp-oop/properties/#auto-implemented-properties",
    "relUrl": "/adev2008/csharp-oop/properties/#auto-implemented-properties"
  },"216": {
    "doc": "Properties",
    "title": "Class Diagram",
    "content": "When a class is defined with properties, a property is indicated in a UML Class Diagram with the &lt;&lt;Property&gt;&gt; notation. Employee . - identificationNumber : int - name : string + &lt;&lt;Property&gt;&gt; IdentificationNumber : int + &lt;&lt;Property&gt;&gt; Name : string . + Employee(identificationNumber : int, name : string) + Employee(identificationNumber : int) . ",
    "url": "http://localhost:8888/adev2008/csharp-oop/properties/#class-diagram",
    "relUrl": "/adev2008/csharp-oop/properties/#class-diagram"
  },"217": {
    "doc": "Properties",
    "title": "Further Reading",
    "content": ". | Properties | Using Properties | . ",
    "url": "http://localhost:8888/adev2008/csharp-oop/properties/#further-reading",
    "relUrl": "/adev2008/csharp-oop/properties/#further-reading"
  },"218": {
    "doc": "Property Tests",
    "title": "Property Tests",
    "content": " ",
    "url": "http://localhost:8888/adev2008/unit-testing/property-tests/",
    "relUrl": "/adev2008/unit-testing/property-tests/"
  },"219": {
    "doc": "Property Tests",
    "title": "Table of Contents",
    "content": ". | Example 1 - Set Accessor Exception | Example 2 - Set Accessor Valid Value | Example 3 - Get Accessor | Auto-Implemented Property Tests | . ",
    "url": "http://localhost:8888/adev2008/unit-testing/property-tests/#table-of-contents",
    "relUrl": "/adev2008/unit-testing/property-tests/#table-of-contents"
  },"220": {
    "doc": "Property Tests",
    "title": "Example 1 - Set Accessor Exception",
    "content": "Test Case: . | # | Test Case | Test Data | Expected | . | 1 | Exception when the value is a negative value | Value: -1 | ArgumentOutOfRangeException, Parameter: value, Message: The value must be zero or greater., State is not updated. | . Testing Goal: Set the property to an invalid value. [TestMethod] public void SetAmountOfMoney_NegativeAmount_Exception() { // Arrange string name = \"Kenny\"; decimal amountOfMoney = 100; Person person = new Person(name, amountOfMoney); // Act &amp; Assert ArgumentOutOfRangeException exception = Assert.ThrowsException&lt;ArgumentOutOfRangeException&gt;(() =&gt; person.AmountOfMoney = -1); // Assert exception state Assert.AreEqual(\"value\", exception.ParamName); Assert.AreEqual(\"The value must be zero or greater.\", GetExceptionMessage(exception.Message)); // Reflection PrivateObject target = new PrivateObject(person); // Obtain object state decimal actual = (decimal)target.GetField(\"amountOfMoney\"); // Assert Assert.AreEqual(amountOfMoney, actual); } . Notes: . | The Assert.ThrowsException() method is used since an exception is expected to occur and the state of the exception is verified. | In most cases, when an exception is thrown in a set accessor, the state should not change to the invalid value. The final Assert statement verifies this. | . ",
    "url": "http://localhost:8888/adev2008/unit-testing/property-tests/#example-1---set-accessor-exception",
    "relUrl": "/adev2008/unit-testing/property-tests/#example-1---set-accessor-exception"
  },"221": {
    "doc": "Property Tests",
    "title": "Example 2 - Set Accessor Valid Value",
    "content": "Test Case: . | # | Test Case | Test Data | Expected | . | 3 | Sets the amount of money to zero | Initial amount of money: 100, Value: 0 | 0 | . Testing Goal: Sets the property to a valid value and verifies the state changed. [TestMethod] public void SetAmountOfMoney_ZeroAmount_UpdateState() { // Arrange string name = \"Kenny\"; decimal amountOfMoney = 100; Person person = new Person(name, amountOfMoney); decimal expected = 0; // Act person.AmountOfMoney = expected; // Reflection PrivateObject target = new PrivateObject(person); // Obtain object state decimal actual = (decimal)target.GetField(\"amountOfMoney\"); // Assert Assert.AreEqual(expected, actual); } . Notes: . | When testing a modification in state, the value you choose to change the state should be different than the initial value. | The variable expected is a recommended practice as it makes the Assert statement clearer. | Due to the result of the unit changing the state, accessing the private field is required to verify the test. | . ",
    "url": "http://localhost:8888/adev2008/unit-testing/property-tests/#example-2---set-accessor-valid-value",
    "relUrl": "/adev2008/unit-testing/property-tests/#example-2---set-accessor-valid-value"
  },"222": {
    "doc": "Property Tests",
    "title": "Example 3 - Get Accessor",
    "content": "Test Case: . | # | Test Case | Test Data | Expected | . | 4 | Gets the amount of money | Initial amount of money: 100 | 100 | . Testing Goal: Initialize the object and obtain its state. [TestMethod] public void GetAmountOfMoney_ReturnsState() { // Arrange string name = \"Kenny\"; decimal amountOfMoney = 100; Person person = new Person(name, amountOfMoney); // Act decimal actual = person.AmountOfMoney; // Assert Assert.AreEqual(amountOfMoney, actual); } . Notes: . | PrivateObject should not be used in this test as no private member is accessed. | . ",
    "url": "http://localhost:8888/adev2008/unit-testing/property-tests/#example-3---get-accessor",
    "relUrl": "/adev2008/unit-testing/property-tests/#example-3---get-accessor"
  },"223": {
    "doc": "Property Tests",
    "title": "Auto-Implemented Property Tests",
    "content": "When a property is auto-implemented, it will not have a field you can access. When you are in this situation, you will use the GetProperty() method of the PrivateObject class. public abstract class Shape { public double XCoordinate { get; set; } } public class Circle : Shape { } . [TestMethod] public void SetXCoordinate_ModifyState() { // Arrange string color = \"Black\"; double radius = 77.7; double xCoordinate = 123.4; Circle circle = new Circle(color, radius); // Act circle.XCoordinate = xCoordinate; PrivateObject target; target = new PrivateObject(circle); double actual = (double)target.GetProperty(\"XCoordinate\"); // Assert Assert.AreEqual(xCoordinate, actual); } . ",
    "url": "http://localhost:8888/adev2008/unit-testing/property-tests/#auto-implemented-property-tests",
    "relUrl": "/adev2008/unit-testing/property-tests/#auto-implemented-property-tests"
  },"224": {
    "doc": "README",
    "title": "How To Use These Course Notes",
    "content": "The following are the features of these course notes: . ",
    "url": "http://localhost:8888/read-me/#how-to-use-these-course-notes",
    "relUrl": "/read-me/#how-to-use-these-course-notes"
  },"225": {
    "doc": "README",
    "title": "Table of Contents",
    "content": ". | Who Are These Notes For? | Documentation Conventions | Code Conventions | Help Improve These Notes | . ",
    "url": "http://localhost:8888/read-me/#table-of-contents",
    "relUrl": "/read-me/#table-of-contents"
  },"226": {
    "doc": "README",
    "title": "Who Are These Notes For?",
    "content": ". | You’ve completed Programming 1. | You are proficient with basic programming concepts. | You are familiar with Object-Oriented Programming. | . ",
    "url": "http://localhost:8888/read-me/#who-are-these-notes-for",
    "relUrl": "/read-me/#who-are-these-notes-for"
  },"227": {
    "doc": "README",
    "title": "Documentation Conventions",
    "content": "You will see the following marker throughout the course notes: . A note of important information about the topic. Calls attention to techniques that will help you produce code that is cleaner, more understandable and more maintainable. Tips for exposing and removing defects in your code. Highlights common errors to help reduce the likeliness that you’ll make them. A concept that needs to be mentioned now, but will be discussed deeper in a future lesson. ",
    "url": "http://localhost:8888/read-me/#documentation-conventions",
    "relUrl": "/read-me/#documentation-conventions"
  },"228": {
    "doc": "README",
    "title": "Code Conventions",
    "content": "Source code examples will appear like: . namespace ADEV.ACE.RRC; internal class HelloWorld { static void Main(string[] args) { Console.WriteLine(\"Hello, programming world!\"); } } . Many of the code examples in these course notes to not contain proper documentation. They are omitted for clarity of the example. Ensure you are following the Coding Conventions and Standards for all your graded course work. ",
    "url": "http://localhost:8888/read-me/#code-conventions",
    "relUrl": "/read-me/#code-conventions"
  },"229": {
    "doc": "README",
    "title": "Help Improve These Notes",
    "content": "You can help improve this manual in three ways: . | If you find any problems with this manual, alert your instructor. | Contact the lead instructor by email daltenburg@rrc.ca. | You can submit a pull request to fix typos, debug code samples, and update explanations using the “Edit this page on Github” link at the bottom of every page. | . ",
    "url": "http://localhost:8888/read-me/#help-improve-these-notes",
    "relUrl": "/read-me/#help-improve-these-notes"
  },"230": {
    "doc": "README",
    "title": "README",
    "content": " ",
    "url": "http://localhost:8888/read-me/",
    "relUrl": "/read-me/"
  },"231": {
    "doc": "Running Unit Tests",
    "title": "Running Unit Tests",
    "content": " ",
    "url": "http://localhost:8888/adev2008/unit-testing/running-unit-tests/",
    "relUrl": "/adev2008/unit-testing/running-unit-tests/"
  },"232": {
    "doc": "Running Unit Tests",
    "title": "Table of Contents",
    "content": ". | Test Explorer | Running Tests | Test Results | Tests That Fail | Tests That Pass | . ",
    "url": "http://localhost:8888/adev2008/unit-testing/running-unit-tests/#table-of-contents",
    "relUrl": "/adev2008/unit-testing/running-unit-tests/#table-of-contents"
  },"233": {
    "doc": "Running Unit Tests",
    "title": "Test Explorer",
    "content": "The Test Explorer is a panel within Visual Studio. It is used to run unit tests. The Test Explorer is not usually visible by default. To open the panel, go to View &gt; Test Explorer on the menu strip or use the keyboard shortcut Ctrl + E, T. While you are unit testing, you may want to pin the Test Explorer panel so it is always visible. Like the Solution Explorer, the Test Explorer is populated with nodes. The first node represents a test project. All the namespaces within the test project will be child nodes of the test project. Test class nodes are child nodes of the namespace nodes. Unit test nodes are child nodes of test class nodes. Test Explorer Hierarchy . | Project . | Namespace . | Unit Test Class . | Unit Test Method | . | . | . | . If the Test Explorer is not populating with your Unit Test Class or Unit Test Methods, ensure you have used the TestClass and TestMethod attributes. Also, the test class must build. Syntax errors may prevent the Test Explorer from populating. ",
    "url": "http://localhost:8888/adev2008/unit-testing/running-unit-tests/#test-explorer",
    "relUrl": "/adev2008/unit-testing/running-unit-tests/#test-explorer"
  },"234": {
    "doc": "Running Unit Tests",
    "title": "Running Tests",
    "content": "It is recommended that after completing a unit test method you will run it. To run a unit test, right-click the unit test method node in the Test Explorer and choose Run from the context menu. You can execute all tests or a grouping of tests. It is recommended to execute tests individually. When a test fails, you will want to fix the defect until the test passes before moving on with your testing. ",
    "url": "http://localhost:8888/adev2008/unit-testing/running-unit-tests/#running-tests",
    "relUrl": "/adev2008/unit-testing/running-unit-tests/#running-tests"
  },"235": {
    "doc": "Running Unit Tests",
    "title": "Test Results",
    "content": "After running a test, the icons next to the Project, Namespace, Class, and Method will show you the result of tests in that grouping. If you select a unit test node in the Test Explorer, the Test Detail Summary panel will populate information about the results of the test. It is important to read this information carefully when a test fails. It is this information that will help you figure out why the test if failing. ",
    "url": "http://localhost:8888/adev2008/unit-testing/running-unit-tests/#test-results",
    "relUrl": "/adev2008/unit-testing/running-unit-tests/#test-results"
  },"236": {
    "doc": "Running Unit Tests",
    "title": "Tests That Fail",
    "content": "A unit test method results in a Failed status when an exception occurs during the execution of the unit test method. Exceptions will occur in two cases: . | The Assert method used to evaluate the result of the test throws an AssertFailedException. | An unexpected exception of any other type is thrown. | . You should not handle exceptions you are not intentionally throwing in your test just to make the test pass. An exception is telling you something is wrong. When a unit test method fails, it doesn’t necessarily mean the unit you are testing has a defect. If you wrote a statement in your unit test that is causing an exception, it will cause the unit test method to fail. To avoid making unnecessary changes to your code, follow these steps: . | Read the test details carefully. In most cases, you can figure out where the problem is from this information. | If the test details are not helping, read through you unit test method code looking for an error. This may require you to trace the code. | If the unit test code looks good, read through the unit’s code that you are testing. This may require you to trace the code. | . If you are not able to solve a failed test, reach out to your instructor for assistance. ",
    "url": "http://localhost:8888/adev2008/unit-testing/running-unit-tests/#tests-that-fail",
    "relUrl": "/adev2008/unit-testing/running-unit-tests/#tests-that-fail"
  },"237": {
    "doc": "Running Unit Tests",
    "title": "Tests That Pass",
    "content": "A unit test method that completes successfully will result an a Passed status. Writing a unit test method and getting a Passed status after running it is a great feeling. You want to also be mindful that a Passed status does not necessarily mean the unit doesn’t have a defect. Consider the following unit test method: . namespace ADEV.UnitTesting { [TestClass] public class PersonTests { [TestMethod] public void TestMethod1() { } } } . Remember that the only criteria for producing a Passed status is for the unit test method to complete successfully. The unit test method above contains no code and will result in a Passed status. ",
    "url": "http://localhost:8888/adev2008/unit-testing/running-unit-tests/#tests-that-pass",
    "relUrl": "/adev2008/unit-testing/running-unit-tests/#tests-that-pass"
  },"238": {
    "doc": "Sample Test Plan",
    "title": "Test Plan",
    "content": " ",
    "url": "http://localhost:8888/adev2008/unit-testing/sample-test-plan/#test-plan",
    "relUrl": "/adev2008/unit-testing/sample-test-plan/#test-plan"
  },"239": {
    "doc": "Sample Test Plan",
    "title": "Introduction",
    "content": ". | Resource: Person Class | Version: 1.0 | Created: 5/12/2022 | Last Updated: 7/21/2022 | Author(s): Kenny Omega | . ",
    "url": "http://localhost:8888/adev2008/unit-testing/sample-test-plan/#introduction",
    "relUrl": "/adev2008/unit-testing/sample-test-plan/#introduction"
  },"240": {
    "doc": "Sample Test Plan",
    "title": "Test Cases",
    "content": "Person(string, decimal) . | # | Test Case | Test Data | Expected | . | 1 | Exception when name is null | Parameter name: null, Parameter amountOfMoney: 500 | ArgumentNullException, Parameter: name, Message: The argument must reference a string object. | . | 2 | Exception when the name has no characters | Parameter name: “”, Parameter amountOfMoney: 500 | ArgumentException, Parameter: name, Message: The argument must contain at least 1 character. | . | 3 | Exception when the amount of money is a negative | Parameter name: “Kenny”, Parameter amountOfMoney: -100 | ArgumentOutOfRangeException, Parameter: amountOfMoney, Message: The argument must be zero or greater. | . | 4 | Initialize the name | Parameter name: “Kenny”, Parameter amountOfMoney: 500 | “Kenny” | . | 5 | Initialize the amount of money to zero | Parameter name: “Kenny”, Parameter amountOfMoney: 0 | 0 | . | 6 | Initialize the amount of money to positive value | Parameter name: “Kenny”, Parameter amountOfMoney: 500 | 500 | . Person(string) . | # | Test Case | Test Data | Expected | . | 1 | Exception when name is null | Parameter name: null | ArgumentNullException, Parameter: name, Message: The argument must reference a string object. | . | 2 | Exception when the name has no characters | Parameter name: “” | ArgumentException, Parameter: name, Message: The argument must contain at least 1 character. | . | 3 | Initialize the name | Parameter name: “Kenny” | “Kenny” | . | 4 | Initialize the amount of money to zero | Parameter name: “Kenny” | 0 | . «Property» AmountOfMoney : decimal . | # | Test Case | Test Data | Expected | . | 1 | Exception when the value is a negative value | Value: -1 | ArgumentOutOfRangeException, Parameter: value, Message: The value must be zero or greater., State is not updated. | . | 3 | Sets the amount of money to zero | Initial amount of money: 100, Value: 0 | 0 | . | 4 | Sets the amount of money to positive value | Initial amount of money: 0, Value: 100 | 100 | . | 5 | Gets the amount of money | Initial amount of money: 100 | 100 | . «Property» Name : string . | # | Test Case | Test Data | Expected | . | 1 | Get the name | Initial name: “Kenny” | “Kenny” | . AddMoney(decimal) : void . | # | Test Case | Test Data | Expected | . | 1 | Exception when the amount is a negative value | Initial amount of money: 0, Parameter amount: -1 | ArgumentOutOfRangeException, Parameter: amount, Message: The argument cannot be less than zero., State is not updated. | . | 2 | Add no money | Initial amount of money: 100, Parameter amount: 0 | Amount of money state: 100 | . | 3 | Add money | Initial amount of money: 100, Parameter amount: 60 | Amount of money state: 160 | . SubtractMoney(decimal) : void . | # | Test Case | Test Data | Expected | . | 1 | Exception when the amount is a negative value | Initial amount of money: 0, Parameter amount: -1 | ArgumentOutOfRangeException, Parameter: amount, Message: The argument cannot be less than zero., State is not updated. | . | 2 | Exception when the amount is greater than the amount of money | Initial amount of money: 100, Parameter amount: 500 | ArgumentOutOfRangeException, Parameter: amount, Message: The argument cannot not exceed the amount of money the Person has., State is not updated. | . | 3 | Subtract no money | Initial amount of money: 100, Parameter amount: 0 | Amount of money state: 100 | . | 4 | Subtract money | Initial amount of money: 100, Parameter amount: 60 | Amount of money state: 40 | . ToString() : string . | # | Test Case | Test Data | Expected | . | 1 | Return string representation of the Person | Initial name: Kenny, Initial amount of money: 123.45M | “Kenny - $123.45” | . Total number of test cases: 23 . ",
    "url": "http://localhost:8888/adev2008/unit-testing/sample-test-plan/#test-cases",
    "relUrl": "/adev2008/unit-testing/sample-test-plan/#test-cases"
  },"241": {
    "doc": "Sample Test Plan",
    "title": "Sample Test Plan",
    "content": " ",
    "url": "http://localhost:8888/adev2008/unit-testing/sample-test-plan/",
    "relUrl": "/adev2008/unit-testing/sample-test-plan/"
  },"242": {
    "doc": "Selections",
    "title": "Selections",
    "content": " ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/selections/",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/selections/"
  },"243": {
    "doc": "Selections",
    "title": "Table of Contents",
    "content": ". | If Statements | Switch Statements | Conditional Operator | Further Reading | . Selections allow you to add logic to your code. All of the comparison, boolean logic and equality operators are the same as Java. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/selections/#table-of-contents",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/selections/#table-of-contents"
  },"244": {
    "doc": "Selections",
    "title": "If Statements",
    "content": "double grade = 77.4; char letterGrade = 'F'; if (grade &gt; 90) { letterGrade = 'A'; } else if (grade &gt; 80) { letterGrade = 'B'; } else if (grade &gt; 70) { letterGrade = 'C'; } else if (grade &gt; 60) { letterGrade = 'D'; } Console.WriteLine(\"Final grade: {0}\", letterGrade); . Output: . Final grade: C . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/selections/#if-statements",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/selections/#if-statements"
  },"245": {
    "doc": "Selections",
    "title": "Switch Statements",
    "content": "DateTime date = DateTime.Now; string message = \"\"; switch (date.DayOfWeek) { case DayOfWeek.Sunday: case DayOfWeek.Saturday: message = \"It's the weekend!\"; break; case DayOfWeek.Monday: case DayOfWeek.Tuesday: message = \"Is it the weekend yet?\"; break; case DayOfWeek.Wednesday: message = \"It's midweek.\"; break; case DayOfWeek.Thursday: case DayOfWeek.Friday: message = \"Almost the weekend. :)\"; break; } Console.WriteLine(\"{0}: {1}\", date.DayOfWeek, message); . Output: . Tuesday: Is it the weekend yet? . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/selections/#switch-statements",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/selections/#switch-statements"
  },"246": {
    "doc": "Selections",
    "title": "Conditional Operator",
    "content": "double grade = 96.2; Console.WriteLine(\"You scored {0}. You {1}.\", grade, grade &gt; 50 ? \"passed\" : \"failed\"); . Output: . You scored 96.2. You passed. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/selections/#conditional-operator",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/selections/#conditional-operator"
  },"247": {
    "doc": "Selections",
    "title": "Further Reading",
    "content": ". | Comparison Operators | Boolean Logic Operators | Equality Operators | Selection Statements | Microsoft if-else if-else Lesson | . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/selections/#further-reading",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/selections/#further-reading"
  },"248": {
    "doc": "Simple Data Binding",
    "title": "Simple Data Binding",
    "content": ". | What is simple data binding | Simple binding to a collection | Simple binding to a single object | Formatting | . ",
    "url": "http://localhost:8888/adev2008/data-binding/simple-data-binding/",
    "relUrl": "/adev2008/data-binding/simple-data-binding/"
  },"249": {
    "doc": "Static Classes",
    "title": "Static Classes",
    "content": " ",
    "url": "http://localhost:8888/adev2008/csharp-oop/static-classes/",
    "relUrl": "/adev2008/csharp-oop/static-classes/"
  },"250": {
    "doc": "Static Classes",
    "title": "Table of Contents",
    "content": ". | Declaring a Static Class | Declaring Static Class Members | Using Static Classes | Class Diagram | Further Reading | . Up to this point, classes have been considered non-static classes. These classes were used to create instances of the type. Static classes are like non-static classes, except you cannot create instances of the type. ",
    "url": "http://localhost:8888/adev2008/csharp-oop/static-classes/#table-of-contents",
    "relUrl": "/adev2008/csharp-oop/static-classes/#table-of-contents"
  },"251": {
    "doc": "Static Classes",
    "title": "Declaring a Static Class",
    "content": "To declare a static class, you will use the static keyword. public static class Math { } . ",
    "url": "http://localhost:8888/adev2008/csharp-oop/static-classes/#declaring-a-static-class",
    "relUrl": "/adev2008/csharp-oop/static-classes/#declaring-a-static-class"
  },"252": {
    "doc": "Static Classes",
    "title": "Declaring Static Class Members",
    "content": "Static classes cannot contain instance members, only static members or constants. public static class Math { public const double PI = 3.1415; public static int Minimum(int a, int b) { } } . ",
    "url": "http://localhost:8888/adev2008/csharp-oop/static-classes/#declaring-static-class-members",
    "relUrl": "/adev2008/csharp-oop/static-classes/#declaring-static-class-members"
  },"253": {
    "doc": "Static Classes",
    "title": "Using Static Classes",
    "content": "To reference members of a static class, you must use the class identifier with dot notation. class Program { static void Main(string[] args) { Console.WriteLine(Math.PI); Console.WriteLine(Math.Minimum(3, 5)); } } . ",
    "url": "http://localhost:8888/adev2008/csharp-oop/static-classes/#using-static-classes",
    "relUrl": "/adev2008/csharp-oop/static-classes/#using-static-classes"
  },"254": {
    "doc": "Static Classes",
    "title": "Class Diagram",
    "content": "In a UML Class Diagram, static classes will be indicated by the &lt;&lt;static&gt;&gt; notation. Static class members will be underlined. &lt;&lt;static&gt;&gt; ClassName . + field : Type = value . + Method() : returnType . ",
    "url": "http://localhost:8888/adev2008/csharp-oop/static-classes/#class-diagram",
    "relUrl": "/adev2008/csharp-oop/static-classes/#class-diagram"
  },"255": {
    "doc": "Static Classes",
    "title": "Further Reading",
    "content": ". | Static Classes and Static Class Members | . ",
    "url": "http://localhost:8888/adev2008/csharp-oop/static-classes/#further-reading",
    "relUrl": "/adev2008/csharp-oop/static-classes/#further-reading"
  },"256": {
    "doc": "Test Planning",
    "title": "Test Planning",
    "content": " ",
    "url": "http://localhost:8888/adev2008/unit-testing/test-planning/",
    "relUrl": "/adev2008/unit-testing/test-planning/"
  },"257": {
    "doc": "Test Planning",
    "title": "Table of Contents",
    "content": ". | Unit Test Plan | Test Order | Determining Unit Outcomes | Constructor | Property | Method | Other Considerations | . The first step to successfully testing software is to have a plan. A detailed test plan outlines testing objectives, resources and processes for testing software. In a very big and complex project, a test plan can be a very lengthy as it typically outlines the group’s overall test strategy. ",
    "url": "http://localhost:8888/adev2008/unit-testing/test-planning/#table-of-contents",
    "relUrl": "/adev2008/unit-testing/test-planning/#table-of-contents"
  },"258": {
    "doc": "Test Planning",
    "title": "Unit Test Plan",
    "content": "A unit test plan is a plan based on the design specifications of a class or program. A typical unit test plan includes a table outlining the following data: . | The class you are testing. | A list of all the units within the class. | Test number. | Description of the outcome/requirement. | Test data needed to test the outcome/requirement. | The expected result (usually a value). | . | . Check out a sample test plan . The Microsoft Excel is a great way to create a test plan. ",
    "url": "http://localhost:8888/adev2008/unit-testing/test-planning/#unit-test-plan",
    "relUrl": "/adev2008/unit-testing/test-planning/#unit-test-plan"
  },"259": {
    "doc": "Test Planning",
    "title": "Test Order",
    "content": "The order that you choose to complete your tests help find defects and prevent false results. Your plan and ultimately your test code should follow this order: . | Constructors | Property Accessors | Methods | . Constructors should be tested first because for all other tests a constructor will need to be invoked. To ensure the integrity of your other tests, you’ll want to make sure your constructors are working as expected. Properties are completed next because in many instances the methods of a class will use the properties. ",
    "url": "http://localhost:8888/adev2008/unit-testing/test-planning/#test-order",
    "relUrl": "/adev2008/unit-testing/test-planning/#test-order"
  },"260": {
    "doc": "Test Planning",
    "title": "Determining Unit Outcomes",
    "content": "The first step to determining unit outcomes is to read all the requirements of the class to have an overall understanding of its purpose. It is difficult to understand the context of unit when you don’t understand how it relates to everything else. For each unit, read the requirement and list each outcome. An outcome is a result of invoking a unit. A unit will always have at least one outcome. In many instances, a unit will have more than one outcome. If you have access to the source code, it can help to read the code of the unit to help you determine outcomes. The following examples outline test cases for a class called Person. A test case defines what must be done to test a unit for a specific outcome. Test cases directly relate to unit tests. You’ll create one unit test for each test case. The Person class represents a person. A Person has two attributes: name and an amount of money. ",
    "url": "http://localhost:8888/adev2008/unit-testing/test-planning/#determining-unit-outcomes",
    "relUrl": "/adev2008/unit-testing/test-planning/#determining-unit-outcomes"
  },"261": {
    "doc": "Test Planning",
    "title": "Constructor",
    "content": "The purpose of every constructor is to set the initial state of an instance of the class. The Person class contains the following constructor: . + Person(name : string, amountOfMoney : name) . The requirement of the method is: . Initializes an instance of the Person class with the specified name and amount of money. Exceptions: . | ArgumentNullException - Thrown when the name is null. | ArgumentException - Thrown when the name does not contain at least 1 character. | ArgumentOutOfRangeException - Thrown when the amountOfMoney is a negative numeric value. | . public Person(string name, decimal amountOfMoney) { if(name == null) throw new ArgumentNullException(\"name\", \"The argument must reference a string object.\"); if (name.Length == 0) throw new ArgumentException(\"name\", \"The argument must contain at least 1 character.\"); if (amountOfMoney &lt; 0) throw new ArgumentOutOfRangeException(\"amountOfMoney\", \"The argument must be zero or greater.\"); this.name = name; this.amountOfMoney = amountOfMoney; } . Constructor Test Cases . | # | Test Case | Test Data | Expected | . | 1 | Exception when name is null | Parameter name: null, Parameter amountOfMoney: 500 | ArgumentNullException, Parameter: name, Message: The argument must reference a string object. | . | 2 | Exception when the name has no characters | Parameter name: “”, Parameter amountOfMoney: 500 | ArgumentException, Parameter: name, Message: The argument must contain at least 1 character. | . | 3 | Exception when the amount of money is a negative | Parameter name: “Kenny”, Parameter amountOfMoney: -100 | ArgumentOutOfRangeException, Parameter: amountOfMoney, Message: The argument must be zero or greater. | . | 4 | Initialize the name | Parameter name: “Kenny”, Parameter amountOfMoney: 500 | “Kenny” | . | 5 | Initialize the amount of money to zero | Parameter name: “Kenny”, Parameter amountOfMoney: 0 | 0 | . | 6 | Initialize the amount of money to positive value | Parameter name: “Kenny”, Parameter amountOfMoney: 500 | 500 | . ",
    "url": "http://localhost:8888/adev2008/unit-testing/test-planning/#constructor",
    "relUrl": "/adev2008/unit-testing/test-planning/#constructor"
  },"262": {
    "doc": "Test Planning",
    "title": "Property",
    "content": "The Person class contains the following property: . + &lt;&lt;Property&gt;&gt; AmountOfMoney : decimal . The requirement of the method is: . Gets and sets the amount of money the person has. Exceptions: . | ArgumentOutOfRangeException - Thrown when the value is a negative numeric value. | . public decimal AmountOfMoney { get { return this.amountOfMoney; } set { if(value &lt; 0) throw new ArgumentOutOfRangeException(\"value\", \"The value must be zero or greater.\"); this.amountOfMoney = value; } } . | # | Test Case | Test Data | Expected | . | 1 | Exception when the value is a negative value | Value: -1 | ArgumentOutOfRangeException, Parameter: value, Message: The value must be zero or greater., State is not updated. | . | 3 | Sets the amount of money to zero | Initial amount of money: 100, Value: 0 | 0 | . | 4 | Sets the amount of money to positive value | Initial amount of money: 0, Value: 100 | 100 | . | 5 | Gets the amount of money | Initial amount of money: 100 | 100 | . ",
    "url": "http://localhost:8888/adev2008/unit-testing/test-planning/#property",
    "relUrl": "/adev2008/unit-testing/test-planning/#property"
  },"263": {
    "doc": "Test Planning",
    "title": "Method",
    "content": "The Person class contains the following method: . + SubtractMoney(amount : decimal) : void . The requirement of the method is: . Subtracts the specified amount of money from the amount of money the Person has. Exceptions: . | ArgumentOutOfRangeException - Thrown when amount is less than zero or exceeds the amount of money the Person has. | . public void SubtractMoney(decimal amount) { if (amount &lt; 0) { throw new ArgumentOutOfRangeException(\"amount\", \"The argument cannot be less than zero.\"); } if (amount &gt; this.amountOfMoney) { throw new ArgumentOutOfRangeException(\"amount\", \"The argument cannot not exceed the amount of money the Person has.\"); } this.amountOfMoney -= amount; } . | # | Test Case | Test Data | Expected | . | 1 | Exception when the amount is a negative value | Initial amount of money: 0, Parameter amount: -1 | ArgumentOutOfRangeException, Parameter: amount, Message: The argument cannot be less than zero. | . | 2 | Exception when the amount is greater than the amount of money | Initial amount of money: 100, Parameter amount: 500 | ArgumentOutOfRangeException, Parameter: amount, Message: The argument cannot not exceed the amount of money the Person has. | . | 3 | Subtract no money | Initial amount of money: 100, Parameter amount: 0 | Amount of money state: 100 | . | 4 | Subtract money | Initial amount of money: 100, Parameter amount: 60 | Amount of money state: 40 | . ",
    "url": "http://localhost:8888/adev2008/unit-testing/test-planning/#method",
    "relUrl": "/adev2008/unit-testing/test-planning/#method"
  },"264": {
    "doc": "Test Planning",
    "title": "Other Considerations",
    "content": ". | Selections that use the &lt;= or &gt;= operators, would equate to two test cases. | . ",
    "url": "http://localhost:8888/adev2008/unit-testing/test-planning/#other-considerations",
    "relUrl": "/adev2008/unit-testing/test-planning/#other-considerations"
  },"265": {
    "doc": "Testing Classes",
    "title": "Testing Classes",
    "content": "The test programs will be written in the following format: . | Each test case is written in a separate method in the program class. These methods are called a unit test method. Your test class will have one unit test method per test in the test plan. | Each unit test method will only test one outcome. | Each unit test method will only be invoked in the main method. | . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/testing-classes/",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/testing-classes/"
  },"266": {
    "doc": "Testing Classes",
    "title": "Method Identifiers",
    "content": "Test method identifiers will generally follow this format: . MethodBeingTestedIdentifier_DataUsedInTheTest_TheOutcomeBeingTested . Example: . static void SetMilesDriven_MilesDrivenBelowZero_StateNotUpdated() { } . Constructors . static void Constructor_Model_Initialize() { } . If the class has more than one constructor method, you can append a number to the end of the word “Constructor”. static void Constructor2_Model_Initialize() { } . Accessor Method . public static void GetMilesDriven_ReturnsState() { } . Mutator Method . static void SetMilesDriven_GreaterThanZero_StateUpdated() { } . Unit test methods do not require documentation. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/testing-classes/#method-identifiers",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/testing-classes/#method-identifiers"
  },"267": {
    "doc": "Testing Classes",
    "title": "Writing Unit Test Methods",
    "content": "The implementation of a unit test method follows a general pattern: . | Setup | Invoke | Verify | . Setup . In the setup portion of the unit test, data required for the test is stored in variables. The number of variables will typically depend on how many arguments needed for methods invoked in the test. This section is also used to create an instance of the class you are testing, except when the test is for the constructor. Invoke . To test any method, the method you are testing must be invoked. Verify . The last part of the unit test is to verify the outcome you are testing worked as expected. You will output the expected value along with the value that resulted out of executing the method you are testing. The examples below include comments where each of the three parts of the test start. static void Constructor1_Model_Initialize() { // Setup String model = \"Honda Ridgeline\"; int milesDriven = 10000; double gallonsOfGas = 40.2; // Invoke Automobile target = new Automobile(model, milesDriven, gallonsOfGas); // Verify String expected = \"Honda Ridgeline\"; String actual = target.getModel(); Console.WriteLine(\"Expected: {0}\\nActual: {1}\\n\", expected, actual); } static void SetModel_Model_StateUpdated() { // Setup String model = \"Honda Ridgeline\"; int milesDriven = 10000; double gallonsOfGas = 40.2; Automobile target = new Automobile(model, milesDriven, gallonsOfGas); // Invoke target.setModel(\"Ford Focus\"); // Verify String expected = \"Ford Focus\"; String actual = target.getModel(); Console.WriteLine(\"Expected: {0}\\nActual: {1}\\n\", expected, actual); } . You’ll notice in the examples above that when you are testing the constructor method, creating the instance of the class is the Invoke portion of the test. When testing all other methods, invoking the constructor method to create the object is part of the Setup. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/testing-classes/#writing-unit-test-methods",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/testing-classes/#writing-unit-test-methods"
  },"268": {
    "doc": "Testing Classes",
    "title": "Test Program Format",
    "content": "For each method you are testing, the test program will print a heading indicating the method being tested. Example . GetAge() : int &lt;/pre&gt; . Leave one blank line before printing the method being tested, except for the first method. Unit Test Output . Each unit test will output the following information: . | The test number and description of the test. | The expected result. | The actual result. | . Format . Test #{test number} - Description of the test. Expected: {expected value} Actual: {actual value} . Example . Test #1 - Returns the current state of age. Expected: 34 Actual: 34 . Below is an output example of testing a method that has more than one outcome. Ensure to leave one blank line between unit test method output. Person(String, int) Test #1 - Initializes the name. Expected: Kenny Actual: Kenny Test #2 - Initializes the age. Expected: 34 Actual: 34 . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/testing-classes/#test-program-format",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/testing-classes/#test-program-format"
  },"269": {
    "doc": "Testing Classes",
    "title": "Executing Tests",
    "content": "To execute the tests, you will run the test program. It is recommended that you execute your tests after writing each test. Don’t wait until you write all the tests to execute the tests. Test Results . Each unit test method will print the expected an actual values of the test. If the values are the same, the test is considered to have a status of pass. If the values are not the same, the test status is considered a fail. Failed Tests . When a test fails, it is recommended that you deal with the failed test before moving on with the remainder of the testing. Perform these steps when your unit test method has a fail status: . | Trace your unit test method’s implementation. A failed test does not necessarily mean the code you are testing has a defect. A mistake in your unit test code can cause the test to appear as a fail. | Trace the code you are testing. After you are assured the unit test was written correctly, trace the code you are testing to find the defect. | . What do I do if I can’t get the test to pass? . It is recommended that you seek advice from your instructor before making major changes to your code. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/testing-classes/#executing-tests",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/testing-classes/#executing-tests"
  },"270": {
    "doc": "Testing Classes",
    "title": "Sample",
    "content": "/* * Name: Chris Jericho * Program: Business Information Technology * Course: ADEV-2008 Programming 2 * Created: 2021-01-01 * Updated: 2021-01-01 */ using System; using Module1.Demo.Library; namespace Module1TestingDemonstration { /// &lt;summary&gt; /// A test program for the Fan class. /// &lt;/summary&gt; class Program { static void Main(string[] args) { int testNumber = 0; // Unit Tests // Fan(FanColor, double, decimal) Console.WriteLine(\"Testing method Fan(FanColor, double, decimal)\\n\"); Console.WriteLine(\"Test {0}\", ++testNumber); Constructor1_Color_Initialize(); Console.WriteLine(\"Test {0}\", ++testNumber); Constructor1_Radius_Initialize(); Console.WriteLine(\"Test {0}\", ++testNumber); Constructor1_Price_Initialize(); Console.WriteLine(\"Test {0}\", ++testNumber); Constructor1_Speed_Initialize(); testNumber = 0; // Fan(FanColor, double) Console.WriteLine(\"Testing method Fan(FanColor, double)\\n\"); Console.WriteLine(\"Test {0}\", ++testNumber); Constructor2_Color_Initialize(); Console.WriteLine(\"Test {0}\", ++testNumber); Constructor2_Radius_Initialize(); Console.WriteLine(\"Test {0}\", ++testNumber); Constructor2_Price_Initialize(); Console.WriteLine(\"Test {0}\", ++testNumber); Constructor2_Speed_Initialize(); testNumber = 0; // Fan(double) Console.WriteLine(\"Testing method Fan(double)\\n\"); Console.WriteLine(\"Test {0}\", ++testNumber); Constructor3_Color_Initialize(); Console.WriteLine(\"Test {0}\", ++testNumber); Constructor3_Radius_Initialize(); Console.WriteLine(\"Test {0}\", ++testNumber); Constructor3_Price_Initialize(); Console.WriteLine(\"Test {0}\", ++testNumber); Constructor3_Speed_Initialize(); testNumber = 0; // Fan.MAXIMUM_SPEED Console.WriteLine(\"Testing class constant MAXIMUM_SPEED\\n\"); Console.WriteLine(\"Test {0}\", ++testNumber); Maximum_Speed_Initialize(); testNumber = 0; // SetFanSpeed(FanSpeed) Console.WriteLine(\"Testing method SetFanSpeed(FanSpeed)\\n\"); Console.WriteLine(\"Test {0}\", ++testNumber); SetFanSpeed_Medium_ModifyState(); testNumber = 0; // IsOn() Console.WriteLine(\"Testing method IsOn()\\n\"); Console.WriteLine(\"Test {0}\", ++testNumber); IsOn_False(); Console.WriteLine(\"Test {0}\", ++testNumber); IsOn_True(); testNumber = 0; // IncreasedSpeed() Console.WriteLine(\"Testing method IncreaseSpeed()\\n\"); Console.WriteLine(\"Test {0}\", ++testNumber); IncreaseSpeed_NotAtMaximumSpeed_StateUpdated(); Console.WriteLine(\"Test {0}\", ++testNumber); IncreaseSpeed_AtMaximumSpeed_StateNotUpdated(); testNumber = 0; // DecreaseSpeed() Console.WriteLine(\"Testing method DecreaseSpeed()\\n\"); Console.WriteLine(\"Test {0}\", ++testNumber); DecreaseSpeed_NotAtMinimumSpeed_StateUpdated(); Console.WriteLine(\"Test {0}\", ++testNumber); DecreaseSpeed_AtMinimumSpeed_StateNotUpdated(); testNumber = 0; // ToString() Console.WriteLine(\"Testing method ToString()\\n\"); Console.WriteLine(\"Test {0}\", ++testNumber); ToString_Returns(); Console.Write(\"Press any key to continue...\"); Console.ReadKey(); } // Fan(FanColor, double, decimal) static void Constructor1_Color_Initialize() { FanColor color = FanColor.Red; double radius = 5; decimal price = 15.99M; Fan target = new Fan(color, radius, price); FanColor expected = FanColor.Red; FanColor actual = target.GetFanColor(); Console.WriteLine(\"Expected: {0}\", expected); Console.WriteLine(\"Actual: {0}\\n\", actual); } static void Constructor1_Radius_Initialize() { FanColor color = FanColor.Red; double radius = 5; decimal price = 15.99M; Fan target = new Fan(color, radius, price); double expected = 5; double actual = target.GetRadius(); Console.WriteLine(\"Expected: {0}\", expected); Console.WriteLine(\"Actual: {0}\\n\", actual); } static void Constructor1_Price_Initialize() { FanColor color = FanColor.Red; double radius = 5; decimal price = 15.99M; Fan target = new Fan(color, radius, price); decimal expected = 15.99M; decimal actual = target.GetPrice(); Console.WriteLine(\"Expected: {0}\", expected); Console.WriteLine(\"Actual: {0}\\n\", actual); } static void Constructor1_Speed_Initialize() { FanColor color = FanColor.Red; double radius = 5; decimal price = 15.99M; Fan target = new Fan(color, radius, price); FanSpeed expected = FanSpeed.Off; FanSpeed actual = target.GetFanSpeed(); Console.WriteLine(\"Expected: {0}\", expected); Console.WriteLine(\"Actual: {0}\\n\", actual); } // Fan(FanColor, double) static void Constructor2_Color_Initialize() { FanColor color = FanColor.Red; double radius = 5; Fan target = new Fan(color, radius); FanColor expected = FanColor.Red; FanColor actual = target.GetFanColor(); Console.WriteLine(\"Expected: {0}\", expected); Console.WriteLine(\"Actual: {0}\\n\", actual); } static void Constructor2_Radius_Initialize() { FanColor color = FanColor.Red; double radius = 5; Fan target = new Fan(color, radius); double expected = 5; double actual = target.GetRadius(); Console.WriteLine(\"Expected: {0}\", expected); Console.WriteLine(\"Actual: {0}\\n\", actual); } static void Constructor2_Price_Initialize() { FanColor color = FanColor.Red; double radius = 5; Fan target = new Fan(color, radius); decimal expected = 0; decimal actual = target.GetPrice(); Console.WriteLine(\"Expected: {0}\", expected); Console.WriteLine(\"Actual: {0}\\n\", actual); } static void Constructor2_Speed_Initialize() { FanColor color = FanColor.Red; double radius = 5; Fan target = new Fan(color, radius); FanSpeed expected = FanSpeed.Off; FanSpeed actual = target.GetFanSpeed(); Console.WriteLine(\"Expected: {0}\", expected); Console.WriteLine(\"Actual: {0}\\n\", actual); } // Fan(double) static void Constructor3_Color_Initialize() { double radius = 5; Fan target = new Fan(radius); FanColor expected = FanColor.White; FanColor actual = target.GetFanColor(); Console.WriteLine(\"Expected: {0}\", expected); Console.WriteLine(\"Actual: {0}\\n\", actual); } static void Constructor3_Radius_Initialize() { double radius = 5; Fan target = new Fan(radius); double expected = 5; double actual = target.GetRadius(); Console.WriteLine(\"Expected: {0}\", expected); Console.WriteLine(\"Actual: {0}\\n\", actual); } static void Constructor3_Price_Initialize() { double radius = 5; Fan target = new Fan(radius); decimal expected = 0; decimal actual = target.GetPrice(); Console.WriteLine(\"Expected: {0}\", expected); Console.WriteLine(\"Actual: {0}\\n\", actual); } static void Constructor3_Speed_Initialize() { double radius = 5; Fan target = new Fan(radius); FanSpeed expected = FanSpeed.Off; FanSpeed actual = target.GetFanSpeed(); Console.WriteLine(\"Expected: {0}\", expected); Console.WriteLine(\"Actual: {0}\\n\", actual); } // Fan() static void Constructor_Color_Initialize() { Fan target = new Fan(); FanColor expected = FanColor.White; FanColor actual = target.GetFanColor(); Console.WriteLine(\"Expected: {0}\", expected); Console.WriteLine(\"Actual: {0}\\n\", actual); } static void Constructor4_Radius_Initialize() { Fan target = new Fan(); double expected = 0; double actual = target.GetRadius(); Console.WriteLine(\"Expected: {0}\", expected); Console.WriteLine(\"Actual: {0}\\n\", actual); } static void Constructor4_Price_Initialize() { Fan target = new Fan(); decimal expected = 0; decimal actual = target.GetPrice(); Console.WriteLine(\"Expected: {0}\", expected); Console.WriteLine(\"Actual: {0}\\n\", actual); } static void Constructor4_Speed_Initialize() { Fan target = new Fan(); FanSpeed expected = FanSpeed.Off; FanSpeed actual = target.GetFanSpeed(); Console.WriteLine(\"Expected: {0}\", expected); Console.WriteLine(\"Actual: {0}\\n\", actual); } static void Maximum_Speed_Initialize() { int expected = 3; int actual = Fan.MAXIMUM_SPEED; Console.WriteLine(\"Expected: {0}\", expected); Console.WriteLine(\"Actual: {0}\\n\", actual); } static void SetFanSpeed_Medium_ModifyState() { Fan target = new Fan(); target.SetFanSpeed(FanSpeed.Medium); FanSpeed expected = FanSpeed.Medium; FanSpeed actual = target.GetFanSpeed(); Console.WriteLine(\"Expected: {0}\", expected); Console.WriteLine(\"Actual: {0}\\n\", actual); } static void IsOn_False() { Fan target = new Fan(); bool expected = false; bool actual = target.IsOn(); Console.WriteLine(\"Expected: {0}\", expected); Console.WriteLine(\"Actual: {0}\\n\", actual); } static void IsOn_True() { Fan target = new Fan(); target.SetFanSpeed(FanSpeed.Medium); bool expected = true; bool actual = target.IsOn(); Console.WriteLine(\"Expected: {0}\", expected); Console.WriteLine(\"Actual: {0}\\n\", actual); } static void IncreaseSpeed_NotAtMaximumSpeed_StateUpdated() { Fan target = new Fan(); target.IncreaseSpeed(); FanSpeed expected = FanSpeed.Slow; FanSpeed actual = target.GetFanSpeed(); Console.WriteLine(\"Expected: {0}\", expected); Console.WriteLine(\"Actual: {0}\\n\", actual); } static void IncreaseSpeed_AtMaximumSpeed_StateNotUpdated() { Fan target = new Fan(); target.SetFanSpeed(FanSpeed.Fast); target.IncreaseSpeed(); FanSpeed expected = FanSpeed.Fast; FanSpeed actual = target.GetFanSpeed(); Console.WriteLine(\"Expected: {0}\", expected); Console.WriteLine(\"Actual: {0}\\n\", actual); } static void DecreaseSpeed_NotAtMinimumSpeed_StateUpdated() { Fan target = new Fan(); target.SetFanSpeed(FanSpeed.Medium); target.DecreaseSpeed(); FanSpeed expected = FanSpeed.Slow; FanSpeed actual = target.GetFanSpeed(); Console.WriteLine(\"Expected: {0}\", expected); Console.WriteLine(\"Actual: {0}\\n\", actual); } static void DecreaseSpeed_AtMinimumSpeed_StateNotUpdated() { Fan target = new Fan(); target.DecreaseSpeed(); FanSpeed expected = FanSpeed.Off; FanSpeed actual = target.GetFanSpeed(); Console.WriteLine(\"Expected: {0}\", expected); Console.WriteLine(\"Actual: {0}\\n\", actual); } static void ToString_Returns() { FanColor color = FanColor.Red; double radius = 5; decimal price = 15.99M; Fan target = new Fan(color, radius, price); String expected = \"Color: Red, Radius: 5, Speed: Off, Price: $15.99\"; String actual = target.ToString(); Console.WriteLine(\"Expected: {0}\", expected); Console.WriteLine(\"Actual: {0}\\n\", actual); } } } . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/testing-classes/#sample",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/testing-classes/#sample"
  },"271": {
    "doc": "Text File IO",
    "title": "Text File IO",
    "content": ". | Use the content already created for Learn | . ",
    "url": "http://localhost:8888/adev2008/text-file-io/text-file-io/",
    "relUrl": "/adev2008/text-file-io/text-file-io/"
  },"272": {
    "doc": "Unit Testing",
    "title": "Unit Testing",
    "content": "The section will help you answer the following questions: . | Testing takes too long. Is there a way to make testing more efficient? | How can I test properly, when values (results) are stored privately in an object?  | . ",
    "url": "http://localhost:8888/adev2008/unit-testing/unit-testing/",
    "relUrl": "/adev2008/unit-testing/unit-testing/"
  },"273": {
    "doc": "Unit Testing",
    "title": "Learning Objectives",
    "content": ". | Create and configure an MSTest project in Visual Studio. | Explain the purpose and process of unit testing. | Develop unit test classes and methods to test code you’ve written. | Understand and follow a test plan. | . ",
    "url": "http://localhost:8888/adev2008/unit-testing/unit-testing/#learning-objectives",
    "relUrl": "/adev2008/unit-testing/unit-testing/#learning-objectives"
  },"274": {
    "doc": "The Visual Studio IDE",
    "title": "The Visual Studio IDE",
    "content": " ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/visual-studio-ide/",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/visual-studio-ide/"
  },"275": {
    "doc": "The Visual Studio IDE",
    "title": "Table of Contents",
    "content": ". | Visual Studio Community . | Note to Mac Users | . | Download | Installing | First Launch of Visual Studio | Configure Visual Studio . | Recommended Option Changes | Optional Option Changes | Required Extension Install | Recommended Extension Install | . | The Environment . | Solution Explorer | Adding Source Code Files | Removing Source Code Files | . | Building (Compiling) a Project | Running a Application | Opening An Existing Project | Further Reading | . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/visual-studio-ide/#table-of-contents",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/visual-studio-ide/#table-of-contents"
  },"276": {
    "doc": "The Visual Studio IDE",
    "title": "Visual Studio Community",
    "content": "There are many code editors you can use to develop .NET applications. In this course, you will use the Visual Studio Community Integrated Development Environment (IDE). For the purposes of these course notes, Visual Studio Community will simply be referred to as Visual Studio or VS. Visual Studio is a free IDE for developing .NET applications. The install is modular, allowing you to install the things you need to develop the type of applications you want. Visual Studio is a very complex tool and is not really intended for beginner programmers. That being said, Visual Studio is the best and most efficient IDE for developing Windows applications. Take time early in this course to practice using Visual Studio. Note to Mac Users . Although there is a version of Visual Studio for Mac, you will not be able to complete this course with it. You will require a Windows OS to complete this course. You can: . | Use Boot Camp (or equivalent software) to run Windows on your Mac. | . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/visual-studio-ide/#visual-studio-community",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/visual-studio-ide/#visual-studio-community"
  },"277": {
    "doc": "The Visual Studio IDE",
    "title": "Download",
    "content": ". | Navigate to https://visualstudio.microsoft.com/vs/community/ using a browser on your computer. | Click the Download Visual Studio link to download the installer executable file. Depending on your browser settings, the install file may download automatically to the default download directory. | . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/visual-studio-ide/#download",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/visual-studio-ide/#download"
  },"278": {
    "doc": "The Visual Studio IDE",
    "title": "Installing",
    "content": ". | Run the installer by double-clicking on the installer executable file. | It is very likely the installer will need to do some configuration before the install process happens. Click the Continue button. When the installer application loads, you will be presented a window where you will choose the development tools you wish to install. The initial page should display Workloads. If not, click Workloads. | Check only the following item(s): . | .NET desktop development | . You can change the directory that Visual Studio will get installed to in the bottom left corner of the window. | Click the Install button located in the bottom right corner. The installation could take more than an hour to download and install the selected tools, depending on your system and internet connection. | . When the installation completes, you can close the installer. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/visual-studio-ide/#installing",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/visual-studio-ide/#installing"
  },"279": {
    "doc": "The Visual Studio IDE",
    "title": "First Launch of Visual Studio",
    "content": "When you launch Visual Studio for the first time, you will be prompted to sign in using a Microsoft account. You must sign in, in order to unlock the IDE. It will also enable you to use services like Git. | If you have a Red River College account, you can sign in with your Red River College credentials. | If you have a Microsoft account, you can sign in with your Microsoft account. | If you don’t have a Microsoft account, and would like to sign in, you can click the Sign up link. | If you don’t wish to sign in, click the Not now, maybe later link. | . If you do not sign in, the application will prompt you for a license. You will need to sign in to unblock yourself. For more information about signing in to Visual Studio click here. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/visual-studio-ide/#first-launch-of-visual-studio",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/visual-studio-ide/#first-launch-of-visual-studio"
  },"280": {
    "doc": "The Visual Studio IDE",
    "title": "Configure Visual Studio",
    "content": ". | Launch Visual Studio Community. | Open Visual Studio without Code. | Go to Tools &gt; Options in the menu strip. This will open the Options dialog window. | . Recommended Option Changes . | Disable line completion. Disabling line completions disables IntelliCode from prompting you for completion suggestions. These completion suggestions sound like they would be a great thing, but they are usually not what you want to do. They can be very tempting to use and will most likely lead to mistakes. Also, it is not a good learning tool. | . Optional Option Changes . | Update the color theme of the Visual Studio user interface. | Update the default save location for projects. | Disable CodeLens. Disabling CodeLens removes the reference count above the declaration of classes and its members. | . You may be required to close all Visual Studio Community instances in order for the option changes to be applied. It is not recommended to make any other options changes. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/visual-studio-ide/#configure-visual-studio",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/visual-studio-ide/#configure-visual-studio"
  },"281": {
    "doc": "The Visual Studio IDE",
    "title": "Visual Studio Extensions",
    "content": "Extensions are tools that extend the functionality of Visual Studio. To install an extension, you’ll need to open the Manage Extension dialog window, search for an extension in the Online catalogue and click the Download button to download and install the extension. Required Extension Install . | Live Share . The Live Share extension may have be installed during your Visual Studio Community install. If there is a green check mark icon in the top right corner of the extension in the search result list, this means the extension is already installed. If you don’t see the green check mark, you will need to download and install this extension. | . Recommended Extension Install . | Spell Checker . You may be required to close all Visual Studio Community instances in order for the option changes to be applied. It is not recommended to install any other extensions. | . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/visual-studio-ide/#visual-studio-extensions",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/visual-studio-ide/#visual-studio-extensions"
  },"282": {
    "doc": "The Visual Studio IDE",
    "title": "The Environment",
    "content": "The first step to learning the Visual Studio tool is to explore the layout of the interface. | Menu Strip - Where you can find all the functionality of Visual Studio. | Toolbar - Where you can find common Visual Studio functions. | Toolbox Panel - You will use this panel later in the course. | File Editor - Where you edit source code. | Solution Explorer - Where you manage solutions and projects. | Properties Panel - Where you can find and modify information about items selected in Visual Studio. | Error List/Output Panel - Where errors and the results of building a project are listed. | . Solution Explorer . The Solution Explorer, typically docked to the top right of the Visual Studio environment, is the most convenient way to manage your Visual Studio Solution and Projects. The Solution Explorer displays the solution, projects, and project files and resources as a tree. Each item in the tree is a node. The root node (top item), is the Solution Node. The nodes attached to Solution Node are the Project Nodes. The nodes attached to the Project Nodes represent resources for the project they are attached to. Adding Source Code Files . To add a new file to a project, Right-click the Project Node and choose “Add &gt; New Item…” from the context menu. This will launch the Add New Item dialog window. This window will list many templates for items you can add to the project. It is recommended that at the beginning of your training to choose the “Code File” template. This template is really just a blank file. Don’t forget to name the file at the bottom of the dialog window and ensure you keep the .cs file extension. Removing Source Code Files . To remove an item from a project, Right-click the Item Node you wish to remove and choose “Delete” from the context menu. It is common for Visual Studio beginners to delete a file using Windows File Explorer. If you do this, the file node will still show up in Visual Studio, but will be represented as a broken link. Always manage your Visual Studio Project files and resources using Visual Studio’s Solution Explorer. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/visual-studio-ide/#the-environment",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/visual-studio-ide/#the-environment"
  },"283": {
    "doc": "The Visual Studio IDE",
    "title": "Building (Compiling) a Project",
    "content": "In the previous level of programming, you were accustom to compiling each source code file. On a successful compilation, a .class file was created. In Visual Studio, source code is compiled by building the project. This will produce a single file called an assembly. To build (compile) a project, right-click the Project Node and choose Build from the context menu. If any of the items within the project cause an error, typically syntax related, those errors will show up in the Error List. On a successful build, the Output Panel will indicate a successful build. A new version of the assembly and other files will be generated in the bin\\Debug directory within the Project directory. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/visual-studio-ide/#building-compiling-a-project",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/visual-studio-ide/#building-compiling-a-project"
  },"284": {
    "doc": "The Visual Studio IDE",
    "title": "Running a Application",
    "content": "There are two ways to run a application: . | Execute the Executable Assembly (.exe) file within the bin\\Debug directory. | Execute the program within Visual Studio. Go to Debug &gt; Start Debugging in the Visual Studio menu strip. | . Class Library Projects do not build to an Executable Assembly (.exe). Therefore, running it will not work. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/visual-studio-ide/#running-a-application",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/visual-studio-ide/#running-a-application"
  },"285": {
    "doc": "The Visual Studio IDE",
    "title": "Opening An Existing Project",
    "content": "To open an existing project, locate the Solution File (.sln) for the solution the project is apart of. Double-clicking the solution file will launch Visual Studio and load the solution and all the solutions projects within Visual Studio. ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/visual-studio-ide/#opening-an-existing-project",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/visual-studio-ide/#opening-an-existing-project"
  },"286": {
    "doc": "The Visual Studio IDE",
    "title": "Further Reading",
    "content": ". | Visual Studio Projects and Solutions | .SLN File | Solution Explorer | . ",
    "url": "http://localhost:8888/adev2008/intro-to-dotnet-csharp-vs/visual-studio-ide/#further-reading",
    "relUrl": "/adev2008/intro-to-dotnet-csharp-vs/visual-studio-ide/#further-reading"
  },"287": {
    "doc": "Windows Forms Apps",
    "title": "Windows Forms Applications",
    "content": "The section will help you answer the following questions: . | How can I build a graphical application in Windows? | Is developing an application for Windows like developing an application in the Console? | How does Visual Studio make developing a graphical application easier? | . ",
    "url": "http://localhost:8888/adev2008/windows-forms-apps/windows-forms-apps/#windows-forms-applications",
    "relUrl": "/adev2008/windows-forms-apps/windows-forms-apps/#windows-forms-applications"
  },"288": {
    "doc": "Windows Forms Apps",
    "title": "Learning Objectives",
    "content": ". | Create a Windows Forms Application. | Develop an application in an Event-Driven way. | Use Visual Studio to design form classes. | Develop a Windows Forms Application using a variety of controls and components. | . ",
    "url": "http://localhost:8888/adev2008/windows-forms-apps/windows-forms-apps/#learning-objectives",
    "relUrl": "/adev2008/windows-forms-apps/windows-forms-apps/#learning-objectives"
  },"289": {
    "doc": "Windows Forms Apps",
    "title": "Windows Forms Apps",
    "content": " ",
    "url": "http://localhost:8888/adev2008/windows-forms-apps/windows-forms-apps/",
    "relUrl": "/adev2008/windows-forms-apps/windows-forms-apps/"
  },"290": {
    "doc": "Winform Basics",
    "title": "Winform Basics",
    "content": ". | What is a Winform App | WFA project | Assembly | Form classes | . ",
    "url": "http://localhost:8888/adev2008/windows-forms-apps/winform-basics/",
    "relUrl": "/adev2008/windows-forms-apps/winform-basics/"
  },"291": {
    "doc": "Winform Control Classes",
    "title": "Winform Control Classes",
    "content": ". | Control | | . ",
    "url": "http://localhost:8888/adev2008/windows-forms-apps/winform-control-classes/",
    "relUrl": "/adev2008/windows-forms-apps/winform-control-classes/"
  },"292": {
    "doc": "Writing Unit Tests",
    "title": "Writing Unit Tests",
    "content": " ",
    "url": "http://localhost:8888/adev2008/unit-testing/writing-unit-tests/",
    "relUrl": "/adev2008/unit-testing/writing-unit-tests/"
  },"293": {
    "doc": "Writing Unit Tests",
    "title": "Table of Contents",
    "content": ". | Unit Test Classes . | Naming Convention | . | Unit Test Methods . | Naming Convention | . | AAA Pattern | Assert Class | Reflection . | PrivateObject Class | PrivateType Class | . | Best Practices For Writing Tests | Test Method Examples | Further Reading | . After creating the test plan, you are now ready to start developing your unit tests. ",
    "url": "http://localhost:8888/adev2008/unit-testing/writing-unit-tests/#table-of-contents",
    "relUrl": "/adev2008/unit-testing/writing-unit-tests/#table-of-contents"
  },"294": {
    "doc": "Writing Unit Tests",
    "title": "Unit Test Classes",
    "content": "Declaring a unit test class is similar to declaring a regular class. The use of the TestClass attribute denotes the class as contain unit tests. namespace ADEV.UnitTesting { [TestClass] public class PersonTests { } } . If your unit test class is missing the TestClass attribute, the Test Explorer will not recognize the class as containing unit tests. Naming Convention . Unit test class identifiers are named by using the class name of the class you are testing followed by the word “Tests”. The test class above is testing a class named Person, because the test class identifier is PersonTests. ",
    "url": "http://localhost:8888/adev2008/unit-testing/writing-unit-tests/#unit-test-classes",
    "relUrl": "/adev2008/unit-testing/writing-unit-tests/#unit-test-classes"
  },"295": {
    "doc": "Writing Unit Tests",
    "title": "Unit Test Methods",
    "content": "You will code unit test methods within the a class with the TestClass attribute. As a general guideline, you will write one unit test method per test case in your test plan. Unit test methods are declared and defined like other methods. The use of the TestMethod attribute denotes the method is a unit test method. namespace ADEV.UnitTesting { [TestClass] public class PersonTests { [TestMethod] public void TestMethod1() { } } } . If your unit test method is missing the TestMethod attribute, the Test Explorer will not recognize the method as a unit tests method. Naming Convention . Unit test method identifiers will follow this general naming format: UnitDescription_Data_Result . Example: . namespace ADEV.UnitTesting { [TestClass] public class PersonTests { [TestMethod] public void Constructor_NameNull_Exception() { } } } . ",
    "url": "http://localhost:8888/adev2008/unit-testing/writing-unit-tests/#unit-test-methods",
    "relUrl": "/adev2008/unit-testing/writing-unit-tests/#unit-test-methods"
  },"296": {
    "doc": "Writing Unit Tests",
    "title": "AAA Pattern",
    "content": "The AAA (Arrange, Act, Assert) is a common pattern for writing unit test methods. | The Arrange part of the unit test defines test data and initializes an object used for the test. | The Act part of the test invokes the unit being tested under the conditions of the test case. | The Assert part of the test verifies that the unit being tested behaved as expected. | . ",
    "url": "http://localhost:8888/adev2008/unit-testing/writing-unit-tests/#aaa-pattern",
    "relUrl": "/adev2008/unit-testing/writing-unit-tests/#aaa-pattern"
  },"297": {
    "doc": "Writing Unit Tests",
    "title": "Assert Class",
    "content": "The Assert class contains a collection of methods to determine the result of a test. If the condition being tested is not met, an AssertFailedException is thrown. Common Method . | AreEqual(Object, Object) - Tests whether the specified objects are equal and throws an exception if the two objects are not equal. | AreNotEqual(Object, Object) - Tests whether the specified values are unequal and throws an exception if the two values are equal. | IsTrue(Boolean) - Tests whether the specified condition is true and throws an exception if the condition is false. | IsFalse(Boolean) - Tests whether the specified condition is false and throws an exception if the condition is true. | ThrowsException&lt;T&gt;() - Tests whether the code specified by delegate action throws exact given exception of type T (and not of derived type) and throws AssertFailedException if code does not throws exception or throws exception of type other than T. This method returns a reference to the exception the exception if one is thrown. | . All Assert methods will throw an AssertFailedException when the condition is not met. The result of the test is a fail. ",
    "url": "http://localhost:8888/adev2008/unit-testing/writing-unit-tests/#assert-class",
    "relUrl": "/adev2008/unit-testing/writing-unit-tests/#assert-class"
  },"298": {
    "doc": "Writing Unit Tests",
    "title": "Reflection",
    "content": "Many of the tests you will develop will involve verifying the state of an object. State is stored in private fields in the class. To verify test cases where the result deals with object state, you will need to use a concept called Reflection. Reflection is the ability to retrieve data that is normally not accessible at run-time. In the testing you did prior to this topic, you would have normally called an accessor method to verify changes to state. This is no longer satisfactory, as one of your unit testing goals is to isolate the unit your are testing. This means you do not want to invoke other units of the class while testing a specific unit. PrivateObject Class . The PrivateObject class represents a public “version” of an object. The class contains methods to accesses private fields, methods, and properties. To gain access to an object’s private members, construct an instance of PrivateObject, initializing it with a reference to the object you wish access its private members. Person person = new Person(name, amountOfMoney); PrivateObject target = new PrivateObject(person); . Use the following methods of the PrivateObject class: . | GetField(String) : Object - Returns the value of the specified field. | SetField(String, Object) : void - Sets the specified field to the specified value. | Invoke(String, Object[]) : Object - Invokes the specified method. The Object[] represents the arguments. Returns the result of the method. | . PrivateObject target = new PrivateObject(person); decimal actual = (decimal)target.GetField(\"amountOfMoney\"); . PrivateType Class . The PrivateType class is used like PrivateObject, but is used for Static Classes. The PrivateType class is also used when gaining access to base class members. ",
    "url": "http://localhost:8888/adev2008/unit-testing/writing-unit-tests/#reflection",
    "relUrl": "/adev2008/unit-testing/writing-unit-tests/#reflection"
  },"299": {
    "doc": "Writing Unit Tests",
    "title": "Best Practices For Writing Tests",
    "content": "Before you really dive into developing your unit tests, keep the following best practices in mind: . | A unit test should only test a single outcome. Do not combine multiple outcomes into a single test method. | A unit is tested in isolation of other units in the class (with the exception of the constructor). | Always test constructor methods first. | Complete all the tests for a unit before moving onto another unit. | Group tests in your test class by unit, not by test type. | Keep the code in your unit test method simple. | Try to order your tests in order of dependency (when known or possible). | No unit is too insignificant to test. | . ",
    "url": "http://localhost:8888/adev2008/unit-testing/writing-unit-tests/#best-practices-for-writing-tests",
    "relUrl": "/adev2008/unit-testing/writing-unit-tests/#best-practices-for-writing-tests"
  },"300": {
    "doc": "Writing Unit Tests",
    "title": "Test Method Examples",
    "content": "The following unit test method examples will follow the sample test plan. Not every test case will be demonstrated here, as some of the test cases will produce similar unit test method implementation. | Constructor Tests | Property Tests | Method Tests | Accessing Base Class Fields | . ",
    "url": "http://localhost:8888/adev2008/unit-testing/writing-unit-tests/#test-method-examples",
    "relUrl": "/adev2008/unit-testing/writing-unit-tests/#test-method-examples"
  },"301": {
    "doc": "Writing Unit Tests",
    "title": "Further Reading",
    "content": ". | Assert Class | PrivateObject Class | PrivateType Class | . ",
    "url": "http://localhost:8888/adev2008/unit-testing/writing-unit-tests/#further-reading",
    "relUrl": "/adev2008/unit-testing/writing-unit-tests/#further-reading"
  }
}
